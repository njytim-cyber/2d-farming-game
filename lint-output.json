[{"filePath":"C:\\Users\\njyti\\Desktop\\Google-Antigravity\\2d-farming-game\\src\\entities\\Animals.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\njyti\\Desktop\\Google-Antigravity\\2d-farming-game\\src\\entities\\Crop.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\njyti\\Desktop\\Google-Antigravity\\2d-farming-game\\src\\entities\\Pet.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'MOVEMENT_SPEED' is defined but never used.","line":6,"column":21,"nodeType":"Identifier","messageId":"unusedVar","endLine":6,"endColumn":35,"suggestions":[{"messageId":"removeVar","data":{"varName":"MOVEMENT_SPEED"},"fix":{"range":[87,103],"text":""},"desc":"Remove unused variable 'MOVEMENT_SPEED'."}]},{"ruleId":"no-unused-vars","severity":1,"message":"'getState' is defined but never used.","line":7,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":7,"endColumn":18,"suggestions":[{"messageId":"removeVar","data":{"varName":"getState"},"fix":{"range":[136,180],"text":""},"desc":"Remove unused variable 'getState'."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Pet Entity\r\n * Follows the player and wanders around\r\n */\r\n\r\nimport { TILE_SIZE, MOVEMENT_SPEED } from '../game/constants.js';\r\nimport { getState } from '../game/state.js';\r\n\r\nexport class Pet {\r\n    constructor(x, y) {\r\n        this.gridX = x;\r\n        this.gridY = y;\r\n        this.visX = x * TILE_SIZE;\r\n        this.visY = y * TILE_SIZE;\r\n        this.isMoving = false;\r\n        this.facing = { x: 0, y: 1 };\r\n\r\n        this.name = 'Dog';\r\n        this.color = '#ffb74d'; // Orange/Brown default\r\n\r\n        this.speed = 175; // Slower than player (400) but smooth\r\n\r\n        // AI State\r\n        this.state = 'IDLE'; // IDLE, FOLLOW, WANDER\r\n        this.moveTimer = 0;\r\n        this.target = null;\r\n    }\r\n\r\n    update(dt, player) {\r\n        // Safety check for NaN coordinates\r\n        if (isNaN(this.visX) || isNaN(this.visY)) {\r\n            this.visX = this.gridX * TILE_SIZE;\r\n            this.visY = this.gridY * TILE_SIZE;\r\n        }\r\n\r\n        if (this.isMoving) {\r\n            this.continueMove(dt);\r\n            return;\r\n        }\r\n\r\n        // AI Logic\r\n        const distToPlayer = Math.hypot(this.gridX - player.gridX, this.gridY - player.gridY);\r\n\r\n        if (distToPlayer > 3) {\r\n            this.state = 'FOLLOW';\r\n        } else if (distToPlayer < 2) {\r\n            this.state = 'IDLE'; // Too close\r\n        } else {\r\n            // Chance to wander if close enough\r\n            if (Math.random() < 0.01) this.state = 'WANDER';\r\n        }\r\n\r\n        if (this.state === 'FOLLOW') {\r\n            this.moveTowards(player.gridX, player.gridY);\r\n        } else if (this.state === 'WANDER') {\r\n            if (Math.random() < 0.05) {\r\n                const dx = Math.floor(Math.random() * 3) - 1;\r\n                const dy = Math.floor(Math.random() * 3) - 1;\r\n                this.tryMove(dx, dy);\r\n            }\r\n        }\r\n    }\r\n\r\n    moveTowards(targetX, targetY) {\r\n        const dx = Math.sign(targetX - this.gridX);\r\n        const dy = Math.sign(targetY - this.gridY);\r\n\r\n        // Try diagonal or axis-aligned move\r\n        if (dx !== 0 && dy !== 0) {\r\n            if (Math.random() < 0.5) this.tryMove(dx, 0);\r\n            else this.tryMove(0, dy);\r\n        } else {\r\n            this.tryMove(dx, dy);\r\n        }\r\n    }\r\n\r\n    tryMove(dx, dy) {\r\n        if (dx === 0 && dy === 0) return;\r\n\r\n        // Simple collision check (can improve later/pass collision fn)\r\n        const newX = this.gridX + dx;\r\n        const newY = this.gridY + dy;\r\n\r\n        // For now, assume map bounds check. Collision with tiles requires map access.\r\n        // We'll pass map/isSolid later or assume simple movement for now\r\n        // Let's assume valid move for simplicity of this snippet, or check bounds\r\n\r\n        this.facing = { x: dx, y: dy };\r\n        this.gridX = newX;\r\n        this.gridY = newY;\r\n        this.isMoving = true;\r\n    }\r\n\r\n    continueMove(dt) {\r\n        const targetX = this.gridX * TILE_SIZE;\r\n        const targetY = this.gridY * TILE_SIZE;\r\n        const speed = this.speed * dt;\r\n\r\n        const dist = Math.hypot(targetX - this.visX, targetY - this.visY);\r\n\r\n        if (dist <= speed) {\r\n            this.visX = targetX;\r\n            this.visY = targetY;\r\n            this.isMoving = false;\r\n        } else {\r\n            this.visX += ((targetX - this.visX) / dist) * speed;\r\n            this.visY += ((targetY - this.visY) / dist) * speed;\r\n        }\r\n    }\r\n\r\n    serialize() {\r\n        return {\r\n            gridX: this.gridX,\r\n            gridY: this.gridY,\r\n            name: this.name,\r\n            color: this.color,\r\n            state: this.state\r\n        };\r\n    }\r\n\r\n    draw(ctx, x, y) {\r\n        const drawX = x - 15;\r\n        const drawY = y - 10;\r\n        const bob = this.isMoving ? Math.sin(Date.now() / 80) * 3 : 0;\r\n\r\n        // Shadow\r\n        ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';\r\n        ctx.beginPath();\r\n        ctx.ellipse(x, y + 10, 15, 5, 0, 0, Math.PI * 2);\r\n        ctx.fill();\r\n\r\n        // Body\r\n        ctx.fillStyle = this.color;\r\n        ctx.fillRect(drawX, drawY + bob, 30, 20);\r\n\r\n        // Head (Perspective dependant on facing)\r\n        const headX = (this.facing.x > 0) ? drawX + 20 : (this.facing.x < 0 ? drawX - 5 : drawX + 7);\r\n        const headY = drawY - 10 + bob;\r\n        ctx.fillRect(headX, headY, 15, 15);\r\n\r\n        // Ears\r\n        ctx.fillStyle = '#6d4c41';\r\n        ctx.fillRect(headX + 2, headY - 4, 4, 6);\r\n        ctx.fillRect(headX + 9, headY - 4, 4, 6);\r\n\r\n        // Legs\r\n        ctx.fillStyle = '#e65100'; // Darker paws\r\n        ctx.fillRect(drawX + 4, drawY + 18 + bob, 6, 6);\r\n        ctx.fillRect(drawX + 20, drawY + 18 + bob, 6, 6);\r\n\r\n        // Tail (wag)\r\n        const wag = Math.sin(Date.now() / 50) * 5;\r\n        const tailX = (this.facing.x > 0) ? drawX - 5 : (this.facing.x < 0 ? drawX + 30 : drawX + 12);\r\n        ctx.fillRect(tailX, drawY + 5 + bob, 5, 8 + wag);\r\n    }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\njyti\\Desktop\\Google-Antigravity\\2d-farming-game\\src\\entities\\Player.js","messages":[{"ruleId":"no-dupe-keys","severity":2,"message":"Duplicate key 'weapon'.","line":33,"column":13,"nodeType":"ObjectExpression","messageId":"unexpected","endLine":33,"endColumn":19}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Player Entity\r\n * Handles player movement, position, and character appearance\r\n */\r\n\r\nimport { TILE_SIZE, MOVEMENT_SPEED, MAP_WIDTH, MAP_HEIGHT, COLORS } from '../game/constants.js';\r\nimport { getState } from '../game/state.js';\r\n\r\nexport class Player {\r\n    constructor(playerData) {\r\n        this.gridX = playerData.gridX;\r\n        this.gridY = playerData.gridY;\r\n        this.visX = playerData.visX;\r\n        this.visY = playerData.visY;\r\n        this.isMoving = playerData.isMoving || false;\r\n        this.facing = playerData.facing || { x: 0, y: 1 };\r\n\r\n        // Appearance\r\n        this.skinColor = playerData.skinColor || COLORS.skin[0];\r\n        this.hairColor = playerData.hairColor || COLORS.hair[1];\r\n        this.shirtColor = playerData.shirtColor || COLORS.shirt[1];\r\n        this.hairStyle = playerData.hairStyle || 0;\r\n\r\n        // Identity\r\n        this.name = playerData.name || 'Farmer';\r\n        this.gender = playerData.gender || 'male'; // 'male' or 'female'\r\n\r\n        this.equipment = playerData.equipment || {\r\n            head: null,\r\n            body: null,\r\n            legs: null,\r\n            weapon: null,\r\n            weapon: null,\r\n            offhand: null\r\n        };\r\n\r\n        // Combat Stats\r\n        this.hp = playerData.hp || 100;\r\n        this.maxHp = playerData.maxHp || 100;\r\n        this.questFlags = playerData.questFlags || {};\r\n\r\n        // Animation state\r\n        this.attackTimer = 0;\r\n        this.isAttacking = false;\r\n\r\n        // Active Buffs (from food consumption)\r\n        this.activeBuffs = playerData.activeBuffs || [];\r\n    }\r\n\r\n    /**\r\n     * Apply a buff from consuming food\r\n     * @param {object} buff - { type, duration, value }\r\n     */\r\n    applyBuff(buff) {\r\n        // Remove existing buff of same type\r\n        this.activeBuffs = this.activeBuffs.filter(b => b.type !== buff.type);\r\n        // Add new buff with remaining time\r\n        this.activeBuffs.push({\r\n            type: buff.type,\r\n            remainingTime: buff.duration,\r\n            value: buff.value\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Update buff timers\r\n     * @param {number} dt - Delta time in seconds\r\n     */\r\n    updateBuffs(dt) {\r\n        this.activeBuffs = this.activeBuffs.filter(buff => {\r\n            buff.remainingTime -= dt;\r\n            return buff.remainingTime > 0;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Get buff value by type\r\n     */\r\n    getBuffValue(type) {\r\n        const buff = this.activeBuffs.find(b => b.type === type);\r\n        return buff ? buff.value : null;\r\n    }\r\n\r\n    /**\r\n     * Get effective movement speed (with buffs)\r\n     */\r\n    getEffectiveSpeed() {\r\n        const speedBuff = this.getBuffValue('speedBoost');\r\n        return speedBuff ? MOVEMENT_SPEED * speedBuff : MOVEMENT_SPEED;\r\n    }\r\n\r\n    /**\r\n     * Get effective max HP (with buffs)\r\n     */\r\n    getEffectiveMaxHp() {\r\n        const hpBuff = this.getBuffValue('maxHpBoost');\r\n        return hpBuff ? this.maxHp + hpBuff : this.maxHp;\r\n    }\r\n\r\n    /**\r\n     * Get energy cost multiplier (with buffs)\r\n     */\r\n    getEnergyCostMultiplier() {\r\n        const energyBuff = this.getBuffValue('energySaver');\r\n        return energyBuff ? energyBuff : 1.0;\r\n    }\r\n\r\n    /**\r\n     * Update player movement (smooth interpolation)\r\n     */\r\n    /**\r\n     * Update player movement (smooth interpolation)\r\n     * @param {number} dt - Delta time in seconds\r\n     */\r\n    update(dt) {\r\n        if (this.attackTimer > 0) {\r\n            this.attackTimer -= dt * 1000;\r\n            if (this.attackTimer <= 0) {\r\n                this.attackTimer = 0;\r\n                this.isAttacking = false;\r\n            }\r\n        }\r\n\r\n        if (!this.isMoving) return;\r\n\r\n        const targetX = this.gridX * TILE_SIZE;\r\n        const targetY = this.gridY * TILE_SIZE;\r\n\r\n        const frameSpeed = this.getEffectiveSpeed() * dt;\r\n        const dist = Math.hypot(targetX - this.visX, targetY - this.visY);\r\n\r\n        if (dist <= frameSpeed) {\r\n            this.visX = targetX;\r\n            this.visY = targetY;\r\n            this.isMoving = false;\r\n        } else {\r\n            this.visX += ((targetX - this.visX) / dist) * frameSpeed;\r\n            this.visY += ((targetY - this.visY) / dist) * frameSpeed;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Try to move in a direction\r\n     * @param {number} dx - X direction (-1, 0, 1)\r\n     * @param {number} dy - Y direction (-1, 0, 1)\r\n     * @param {Function} isSolidFn - Function to check if tile is solid\r\n     * @returns {boolean} Whether move was successful\r\n     */\r\n    tryMove(dx, dy, isSolidFn) {\r\n        if (this.isMoving) return false;\r\n\r\n        const newX = this.gridX + dx;\r\n        const newY = this.gridY + dy;\r\n\r\n        this.facing = { x: dx || 0, y: dy || 0 };\r\n\r\n        if (newX >= 0 && newX < MAP_WIDTH && newY >= 0 && newY < MAP_HEIGHT) {\r\n            if (!isSolidFn(newX, newY)) {\r\n                this.gridX = newX;\r\n                this.gridY = newY;\r\n                this.isMoving = true;\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Get the tile coordinates the player is facing\r\n     */\r\n    getFacingTile() {\r\n        return {\r\n            x: this.gridX + this.facing.x,\r\n            y: this.gridY + this.facing.y\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Set character appearance\r\n     */\r\n    setAppearance({ skinColor, hairColor, shirtColor, hairStyle, name, gender }) {\r\n        if (skinColor !== undefined) this.skinColor = skinColor;\r\n        if (hairColor !== undefined) this.hairColor = hairColor;\r\n        if (shirtColor !== undefined) this.shirtColor = shirtColor;\r\n        if (hairStyle !== undefined) this.hairStyle = hairStyle;\r\n        if (name !== undefined) this.name = name;\r\n        if (gender !== undefined) this.gender = gender;\r\n    }\r\n\r\n    /**\r\n     * Cycle to next hair style\r\n     */\r\n    cycleHairStyle() {\r\n        this.hairStyle = (this.hairStyle + 1) % 3;\r\n    }\r\n\r\n    /**\r\n     * Serialize player data\r\n     */\r\n    serialize() {\r\n        return {\r\n            gridX: this.gridX,\r\n            gridY: this.gridY,\r\n            visX: this.visX,\r\n            visY: this.visY,\r\n            isMoving: this.isMoving,\r\n            facing: this.facing,\r\n            skinColor: this.skinColor,\r\n            hairColor: this.hairColor,\r\n            shirtColor: this.shirtColor,\r\n            hairStyle: this.hairStyle,\r\n            name: this.name,\r\n            gender: this.gender,\r\n            equipment: this.equipment,\r\n            hp: this.hp,\r\n            maxHp: this.maxHp,\r\n            questFlags: this.questFlags,\r\n            attackTimer: this.attackTimer,\r\n            isAttacking: this.isAttacking,\r\n            activeBuffs: this.activeBuffs\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Calculate total attack damage\r\n     */\r\n    getAttack() {\r\n        let dmg = 1; // Base damage\r\n        if (this.equipment && this.equipment.weapon) {\r\n            dmg += (this.equipment.weapon.attack || 0);\r\n        }\r\n        return dmg;\r\n    }\r\n\r\n    /**\r\n     * Take damage\r\n     */\r\n    takeDamage(amount) {\r\n        this.hp = Math.max(0, this.hp - amount);\r\n        return this.hp === 0;\r\n    }\r\n\r\n    /**\r\n     * Trigger attack animation\r\n     */\r\n    startAttack() {\r\n        this.isAttacking = true;\r\n        this.attackTimer = 300; // 300ms animation\r\n    }\r\n\r\n    /**\r\n     * Draw the player character\r\n     * @param {CanvasRenderingContext2D} ctx \r\n     * @param {number} x - Center X position\r\n     * @param {number} y - Center Y position\r\n     */\r\n    draw(ctx, x, y) {\r\n        const drawX = x - 10;\r\n        const drawY = y - 15;\r\n        const state = getState();\r\n        const bob = (state.screen === 'GAME' && this.isMoving)\r\n            ? Math.sin(Date.now() / 100) * 2\r\n            : 0;\r\n\r\n        if (this.gender === 'female') {\r\n            // === FEMALE AVATAR ===\r\n            // Dress/Skirt (replaces legs/lower body)\r\n            ctx.fillStyle = this.shirtColor;\r\n            ctx.beginPath();\r\n            ctx.moveTo(drawX + 2, drawY + 20 + bob);\r\n            ctx.lineTo(drawX + 18, drawY + 20 + bob);\r\n            ctx.lineTo(drawX + 22, drawY + 31 + bob);\r\n            ctx.lineTo(drawX - 2, drawY + 31 + bob);\r\n            ctx.fill();\r\n\r\n            // Legs (visible at bottom)\r\n            ctx.fillStyle = this.skinColor;\r\n            ctx.fillRect(drawX + 6, drawY + 30 + bob, 3, 4);\r\n            ctx.fillRect(drawX + 11, drawY + 30 + bob, 3, 4);\r\n\r\n        } else {\r\n            // === MALE AVATAR ===\r\n            // Legs (Pants)\r\n            ctx.fillStyle = COLORS.pants;\r\n            ctx.fillRect(drawX + 6, drawY + 18 + bob, 4, 12);\r\n            ctx.fillRect(drawX + 11, drawY + 18 - bob, 4, 12);\r\n        }\r\n\r\n        // Body (Upper)\r\n        ctx.fillStyle = this.shirtColor;\r\n        if (this.gender === 'female') {\r\n            // Slightly tapered waist for female\r\n            ctx.beginPath();\r\n            ctx.moveTo(drawX + 4, drawY + 8 + bob);\r\n            ctx.lineTo(drawX + 16, drawY + 8 + bob);\r\n            ctx.lineTo(drawX + 18, drawY + 20 + bob);\r\n            ctx.lineTo(drawX + 2, drawY + 20 + bob);\r\n            ctx.fill();\r\n        } else {\r\n            ctx.fillRect(drawX + 2, drawY + 8 + bob, 16, 12);\r\n        }\r\n\r\n        // Arms\r\n        ctx.fillStyle = this.skinColor;\r\n        ctx.fillRect(drawX - 2, drawY + 8 + bob, 4, 10);\r\n        ctx.fillRect(drawX + 18, drawY + 8 + bob, 4, 10);\r\n\r\n        // Head\r\n        ctx.fillStyle = this.skinColor;\r\n        ctx.fillRect(drawX + 2, drawY - 6 + bob, 16, 14);\r\n\r\n        // Eyes\r\n        ctx.fillStyle = 'black';\r\n        const eyeOffset = (this.facing.x || 0) * 2;\r\n\r\n        if (this.facing.y !== -1) {\r\n            ctx.fillRect(drawX + 5 + eyeOffset, drawY - 2 + bob, 2, 2);\r\n            ctx.fillRect(drawX + 13 + eyeOffset, drawY - 2 + bob, 2, 2);\r\n\r\n            // Gender-specific facial features\r\n            if (this.gender === 'female') {\r\n                // Eyelashes\r\n                ctx.fillStyle = 'black';\r\n                ctx.fillRect(drawX + 4 + eyeOffset, drawY - 3 + bob, 1, 1);\r\n                ctx.fillRect(drawX + 7 + eyeOffset, drawY - 3 + bob, 1, 1);\r\n                ctx.fillRect(drawX + 12 + eyeOffset, drawY - 3 + bob, 1, 1);\r\n                ctx.fillRect(drawX + 15 + eyeOffset, drawY - 3 + bob, 1, 1);\r\n\r\n                // Blush\r\n                ctx.fillStyle = 'rgba(255, 182, 193, 0.6)';\r\n                ctx.fillRect(drawX + 3 + eyeOffset, drawY + 2 + bob, 3, 2);\r\n                ctx.fillRect(drawX + 14 + eyeOffset, drawY + 2 + bob, 3, 2);\r\n            }\r\n        }\r\n\r\n        // Hair\r\n        if (this.hairStyle !== 2) { // 2 is bald\r\n            ctx.fillStyle = this.hairColor;\r\n\r\n            if (this.gender === 'female') {\r\n                if (this.hairStyle === 0) {\r\n                    // Bob cut\r\n                    ctx.fillRect(drawX + 1, drawY - 8 + bob, 18, 6);\r\n                    ctx.fillRect(drawX, drawY - 4 + bob, 4, 12);\r\n                    ctx.fillRect(drawX + 16, drawY - 4 + bob, 4, 12);\r\n                } else if (this.hairStyle === 1) {\r\n                    // Long hair\r\n                    ctx.fillRect(drawX, drawY - 8 + bob, 20, 6);\r\n                    ctx.fillRect(drawX - 2, drawY - 4 + bob, 5, 20);\r\n                    ctx.fillRect(drawX + 17, drawY - 4 + bob, 5, 20);\r\n                    // Back hair (behind body) - drawn here for simplicity\r\n                    ctx.fillRect(drawX + 4, drawY + 2 + bob, 12, 18);\r\n                }\r\n            } else {\r\n                if (this.hairStyle === 0) {\r\n                    // Standard short\r\n                    ctx.fillRect(drawX + 1, drawY - 8 + bob, 18, 5);\r\n                    ctx.fillRect(drawX, drawY - 6 + bob, 3, 8);\r\n                    ctx.fillRect(drawX + 17, drawY - 6 + bob, 3, 8);\r\n                } else if (this.hairStyle === 1) {\r\n                    // Spiky hair\r\n                    ctx.fillRect(drawX + 1, drawY - 7 + bob, 18, 4);\r\n                    for (let i = 0; i < 5; i++) {\r\n                        ctx.fillRect(drawX + 2 + i * 4, drawY - 11 + bob, 2, 4);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // === SWORD ANIMATION ===\r\n        if (this.isAttacking && this.equipment && this.equipment.weapon) {\r\n            this.drawSwordSwing(ctx, drawX + 10, drawY + 15);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Draw sword swing animation\r\n     */\r\n    drawSwordSwing(ctx, cx, cy) {\r\n        const progress = 1 - (this.attackTimer / 300);\r\n        const angle = -Math.PI / 4 + progress * Math.PI / 2; // -45 to +45 deg swing\r\n\r\n        ctx.save();\r\n        ctx.translate(cx, cy);\r\n\r\n        // Rotate based on facing\r\n        if (this.facing.x === 1) ctx.rotate(0);\r\n        else if (this.facing.x === -1) ctx.rotate(Math.PI);\r\n        else if (this.facing.y === 1) ctx.rotate(Math.PI / 2);\r\n        else if (this.facing.y === -1) ctx.rotate(-Math.PI / 2);\r\n\r\n        ctx.rotate(angle);\r\n\r\n        // Draw Sword\r\n        ctx.fillStyle = '#bcaaa4'; // Wood Hilt\r\n        ctx.fillRect(5, -2, 8, 4);\r\n        ctx.fillStyle = '#eeeeee'; // Steel Blade (if it was steel, but it's wooden)\r\n        ctx.fillStyle = '#a1887f'; // Wooden blade color\r\n        ctx.fillRect(13, -3, 20, 6);\r\n\r\n        // Shine/Edge\r\n        ctx.fillStyle = 'rgba(255,255,255,0.3)';\r\n        ctx.fillRect(13, -3, 20, 1);\r\n\r\n        ctx.restore();\r\n    }\r\n}\r\n\r\nexport default Player;\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\njyti\\Desktop\\Google-Antigravity\\2d-farming-game\\src\\game\\Game.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'replaceState' is defined but never used.","line":10,"column":30,"nodeType":"Identifier","messageId":"unusedVar","endLine":10,"endColumn":42,"suggestions":[{"messageId":"removeVar","data":{"varName":"replaceState"},"fix":{"range":[263,277],"text":""},"desc":"Remove unused variable 'replaceState'."}]},{"ruleId":"no-unused-vars","severity":1,"message":"'createInitialState' is defined but never used.","line":10,"column":44,"nodeType":"Identifier","messageId":"unusedVar","endLine":10,"endColumn":62,"suggestions":[{"messageId":"removeVar","data":{"varName":"createInitialState"},"fix":{"range":[277,297],"text":""},"desc":"Remove unused variable 'createInitialState'."}]},{"ruleId":"no-unused-vars","severity":1,"message":"'consumeFood' is defined but never used.","line":27,"column":23,"nodeType":"Identifier","messageId":"unusedVar","endLine":27,"endColumn":34,"suggestions":[{"messageId":"removeVar","data":{"varName":"consumeFood"},"fix":{"range":[1380,1393],"text":""},"desc":"Remove unused variable 'consumeFood'."}]},{"ruleId":"no-undef","severity":2,"message":"'performance' is not defined.","line":321,"column":21,"nodeType":"Identifier","messageId":"undef","endLine":321,"endColumn":32},{"ruleId":"prefer-const","severity":2,"message":"'lastPos' is never reassigned. Use 'const' instead.","line":753,"column":13,"nodeType":"Identifier","messageId":"useConst","endLine":753,"endColumn":20,"fix":{"range":[26113,26252],"text":"const lastPos = state.lastOverworldPos || {\r\n            x: Math.floor(MAP_WIDTH / 2),\r\n            y: Math.floor(MAP_HEIGHT / 2)\r\n        };"}},{"ruleId":"no-unused-vars","severity":1,"message":"'state' is assigned a value but never used.","line":865,"column":15,"nodeType":"Identifier","messageId":"unusedVar","endLine":865,"endColumn":20,"suggestions":[{"messageId":"removeVar","data":{"varName":"state"},"fix":{"range":[29547,29572],"text":""},"desc":"Remove unused variable 'state'."}]},{"ruleId":"no-undef","severity":2,"message":"'ITEM_DATA' is not defined.","line":869,"column":22,"nodeType":"Identifier","messageId":"undef","endLine":869,"endColumn":31},{"ruleId":"no-undef","severity":2,"message":"'location' is not defined.","line":970,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":970,"endColumn":17},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":1269,"column":13,"nodeType":"MemberExpression","messageId":"unexpected","endLine":1269,"endColumn":25,"suggestions":[{"fix":{"range":[44671,44727],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":1,"fixableWarningCount":0,"source":"/**\r\n * Main Game Controller\r\n * Orchestrates all game systems and the main loop\r\n */\r\n\r\nimport {\r\n    TILE_SIZE, MAP_WIDTH, MAP_HEIGHT, TILES, SEEDS,\r\n    ENERGY_COST, INTERIOR_TILES, RESOURCE_TYPES, NPC_IDS\r\n} from './constants.js';\r\nimport { getState, setState, replaceState, createInitialState } from './state.js';\r\nimport { generateMap, isSolid, setTile } from '../systems/MapGenerator.js';\r\nimport { generateHouseInterior, generateShopInterior, generateOldHouseInterior, isInteriorSolid, getInteriorSpawn } from '../systems/InteriorMaps.js';\r\nimport { saveGame, loadGame, hasSave, startAutoSave, onSave, resetGame } from '../systems/SaveManager.js';\r\nimport { Inventory } from '../systems/Inventory.js';\r\nimport { TimeSystem } from '../systems/TimeSystem.js';\r\nimport { Pet } from '../entities/Pet.js';\r\nimport { PetNameModal } from '../ui/PetNameModal.js';\r\nimport { ParticleSystem } from '../systems/ParticleSystem.js';\r\nimport { Player } from '../entities/Player.js';\r\nimport { Renderer } from '../rendering/Renderer.js';\r\nimport { TileRenderer } from '../rendering/TileRenderer.js';\r\nimport { InputManager } from '../input/InputManager.js';\r\nimport { UIManager } from '../ui/UIManager.js';\r\nimport { CreatorModal } from '../ui/CreatorModal.js';\r\nimport { ShopModal } from '../ui/ShopModal.js';\r\nimport { CookingModal } from '../ui/CookingModal.js';\r\nimport { CONSUMABLES, consumeFood } from '../systems/Recipes.js';\r\n\r\nexport class Game {\r\n    constructor() {\r\n        this.canvas = document.getElementById('gameCanvas');\r\n        this.renderer = new Renderer(this.canvas);\r\n        this.tileRenderer = new TileRenderer(this.renderer.ctx);\r\n        this.inputManager = new InputManager();\r\n        this.uiManager = new UIManager();\r\n        this.particleSystem = new ParticleSystem();\r\n\r\n        this.player = null;\r\n        this.inventory = null;\r\n        this.timeSystem = null;\r\n        this.creatorModal = null;\r\n        this.shopModal = null;\r\n        this.cookingModal = null;\r\n\r\n        this.isRunning = false;\r\n        this.bufferedMove = null;\r\n        this.attackCooldown = 0;\r\n    }\r\n\r\n    /**\r\n     * Initialize the game\r\n     */\r\n    init() {\r\n        // Setup save indicator\r\n        onSave(() => this.uiManager.showSaveIndicator());\r\n\r\n        // Setup creator modal\r\n        this.creatorModal = new CreatorModal(\r\n            this.uiManager,\r\n            () => this.startNewGame(),\r\n            () => this.continueGame()\r\n        );\r\n\r\n        // Setup shop modal\r\n        this.shopModal = new ShopModal(this.uiManager, {\r\n            onBuy: (seedType) => this.buyItem(seedType),\r\n            onSell: (slotIndex, value) => this.sellItem(slotIndex, value),\r\n            onClose: () => this.closeShop(),\r\n            onReset: () => this.resetGameData()\r\n        });\r\n\r\n        // Setup house modal buttons\r\n        this.setupHouseModal();\r\n\r\n        // Setup cooking modal\r\n        this.cookingModal = new CookingModal(this.uiManager, {\r\n            onCook: (recipeKey) => {\r\n                this.showToast(`Cooked ${recipeKey.replace(/_/g, ' ')}!`, '#81c784');\r\n                this.syncInventory();\r\n                saveGame();\r\n            },\r\n            onConsume: (slotIdx) => this.consumeFoodItem(slotIdx),\r\n            onClose: () => setState({ screen: 'GAME' })\r\n        });\r\n\r\n        // Initialize with state\r\n        const state = getState();\r\n        this.player = new Player(state.player);\r\n        this.inventory = new Inventory(state.inventory.slots, state.inventory.selected);\r\n        this.timeSystem = new TimeSystem(state);\r\n\r\n        // Setup UI callbacks\r\n        this.uiManager.onSlotSelect((idx) => this.interactWithSelected(idx));\r\n        this.uiManager.onEquip((idx) => this.equipItem(idx));\r\n\r\n        // Show creator/continue screen\r\n        this.creatorModal.show(this.player, hasSave());\r\n\r\n        // Start game loop\r\n        this.isRunning = true;\r\n        this.loop();\r\n    }\r\n\r\n    /**\r\n     * Setup house modal buttons\r\n     */\r\n    setupHouseModal() {\r\n        const sleepBtn = document.querySelector('#house-modal .btn--start');\r\n        const leaveBtn = document.querySelector('#house-modal .btn--secondary');\r\n\r\n        if (sleepBtn) {\r\n            sleepBtn.onclick = () => this.sleep();\r\n        }\r\n        if (leaveBtn) {\r\n            leaveBtn.onclick = () => this.closeHouseModal();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Close house modal without exiting\r\n     */\r\n    closeHouseModal() {\r\n        this.uiManager.setHouseVisible(false);\r\n    }\r\n\r\n    /**\r\n     * Continue existing game\r\n     */\r\n    continueGame() {\r\n        if (loadGame()) {\r\n            const state = getState();\r\n            this.player = new Player(state.player);\r\n            this.inventory = new Inventory(state.inventory.slots, state.inventory.selected);\r\n            this.timeSystem = new TimeSystem(state);\r\n\r\n            // Re-create pet if exists in save (need to add to save schema later)\r\n            // For now, spawn a pet if one isn't saved, or default\r\n            // Re-create pet if exists in save\r\n            if (state.pet) {\r\n                this.pet = new Pet(state.pet.gridX, state.pet.gridY);\r\n                this.pet.name = state.pet.name;\r\n                this.pet.color = state.pet.color;\r\n                this.pet.state = state.pet.state || 'IDLE';\r\n            } else {\r\n                this.pet = new Pet(this.player.gridX + 1, this.player.gridY); // Default companion\r\n            }\r\n\r\n            this.uiManager.setupEquipment(this.player);\r\n\r\n            // Validate player position\r\n            if (this.player.gridX >= MAP_WIDTH || this.player.gridY >= MAP_HEIGHT ||\r\n                isSolid(state.map, this.player.gridX, this.player.gridY, state.crops, SEEDS)) {\r\n                this.player.gridX = Math.floor(MAP_WIDTH / 2);\r\n                this.player.gridY = Math.floor(MAP_HEIGHT / 2);\r\n                this.player.visX = this.player.gridX * TILE_SIZE;\r\n                this.player.visY = this.player.gridY * TILE_SIZE;\r\n            }\r\n\r\n            setState({ screen: 'GAME' });\r\n            this.uiManager.setCreatorVisible(false);\r\n            this.setupInput();\r\n            this.updateUI();\r\n            startAutoSave();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Start a new game\r\n     */\r\n    startNewGame() {\r\n        const { map, npcs } = generateMap();\r\n\r\n        this.player.gridX = Math.floor(MAP_WIDTH / 2);\r\n        this.player.gridY = Math.floor(MAP_HEIGHT / 2);\r\n        this.player.visX = this.player.gridX * TILE_SIZE;\r\n        this.player.visY = this.player.gridY * TILE_SIZE;\r\n        this.player.facing = { x: 0, y: 1 };\r\n\r\n        this.uiManager.setupEquipment(this.player);\r\n\r\n        this.inventory = new Inventory();\r\n        this.inventory.addItem('turnip_seed', 5);\r\n\r\n        this.timeSystem = new TimeSystem();\r\n\r\n        // Spawn Pet for intro (Right of player, definitely visible)\r\n        this.pet = new Pet(32, 30);\r\n        this.petIntroTriggered = false;\r\n\r\n        // Trigger pet intro after a short delay\r\n        setTimeout(() => {\r\n            if (!this.petIntroTriggered) this.triggerPetIntro();\r\n        }, 1000);\r\n\r\n        setState({\r\n            screen: 'GAME',\r\n            map,\r\n            npcs: npcs || [],\r\n            player: this.player.serialize(),\r\n            inventory: this.inventory.serialize(),\r\n            crops: {},\r\n            money: 100,\r\n            zoom: 1.0,\r\n            ...this.timeSystem.serialize()\r\n        });\r\n\r\n        this.uiManager.setCreatorVisible(false);\r\n        this.setupInput();\r\n        this.updateUI();\r\n        saveGame();\r\n        saveGame();\r\n        startAutoSave();\r\n    }\r\n\r\n    triggerPetIntro() {\r\n        if (!this.pet) return;\r\n        this.bufferedMove = null;\r\n        this.attackCooldown = 0;\r\n        this.petIntroTriggered = false;\r\n        this.introActive = true;\r\n        this.pet.state = 'FOLLOW';\r\n        this.showToast('Something is approaching...', '#ffb74d');\r\n    }\r\n\r\n    /**\r\n     * Setup input handlers\r\n     */\r\n    setupInput() {\r\n        this.inputManager.enable();\r\n\r\n        this.inputManager.onMove((dx, dy) => {\r\n            this.attemptMove(dx, dy);\r\n        });\r\n\r\n        this.inputManager.onAction(() => {\r\n            this.interact();\r\n        });\r\n\r\n        this.inputManager.onClick((tileX, tileY) => {\r\n            const state = getState();\r\n            if (state.screen !== 'GAME') return;\r\n\r\n            const dx = tileX - this.player.gridX;\r\n            const dy = tileY - this.player.gridY;\r\n\r\n            if (Math.abs(dx) + Math.abs(dy) === 1) {\r\n                this.player.facing = { x: dx, y: dy };\r\n                setState({ destination: null });\r\n            } else {\r\n                setState({ destination: { x: tileX, y: tileY } });\r\n            }\r\n        });\r\n\r\n        this.inputManager.onZoom((delta) => {\r\n            const state = getState();\r\n            let zoom = state.zoom + delta;\r\n            zoom = Math.max(0.5, Math.min(2.0, zoom));\r\n            setState({ zoom });\r\n        });\r\n\r\n        // Setup canvas input\r\n        this.inputManager.setupCanvasInput(this.canvas, (screenX, screenY) => {\r\n            const state = getState();\r\n            return this.renderer.screenToTile(screenX, screenY, state.camera, state.zoom);\r\n        });\r\n\r\n        // Setup FAB\r\n        const fabBtn = document.getElementById('fab-action');\r\n        if (fabBtn) {\r\n            this.inputManager.setupActionButton(fabBtn);\r\n        }\r\n\r\n        // Setup zoom buttons\r\n        const zoomBtns = document.querySelectorAll('.zoom-btn');\r\n        if (zoomBtns.length >= 2) {\r\n            this.inputManager.setupZoomButtons(zoomBtns[0], zoomBtns[1]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Attempt to move player\r\n     * Handles input buffering\r\n     */\r\n    attemptMove(dx, dy) {\r\n        const state = getState();\r\n        if (state.screen !== 'GAME') return;\r\n\r\n        // Buffer input if already moving\r\n        if (this.player.isMoving) {\r\n            this.bufferedMove = { dx, dy };\r\n            return;\r\n        }\r\n\r\n        // Clear any click-to-move destination when using keyboard\r\n        setState({ destination: null });\r\n\r\n        this.player.facing = { x: dx, y: dy };\r\n        const newX = this.player.gridX + dx;\r\n        const newY = this.player.gridY + dy;\r\n\r\n        // Get current map and check bounds/solidity\r\n        const currentMap = this.getCurrentMap(state);\r\n        const mapHeight = currentMap.length;\r\n        const mapWidth = currentMap[0]?.length || 0;\r\n\r\n        if (newX >= 0 && newX < mapWidth && newY >= 0 && newY < mapHeight) {\r\n            if (!this.isTileSolid(state, newX, newY)) {\r\n                this.player.gridX = newX;\r\n                this.player.gridY = newY;\r\n                this.player.isMoving = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Main game loop\r\n     */\r\n    loop(lastTime) {\r\n        if (!this.isRunning) return;\r\n\r\n        const now = performance.now();\r\n        const dt = lastTime ? (now - lastTime) / 1000 : 1 / 60;\r\n\r\n        this.update(dt);\r\n        this.draw();\r\n\r\n        requestAnimationFrame(() => this.loop(now));\r\n    }\r\n\r\n    /**\r\n     * Update game state\r\n     */\r\n    update(dt) {\r\n        const state = getState();\r\n        if (state.screen !== 'GAME') return;\r\n\r\n        if (this.attackCooldown > 0) this.attackCooldown--;\r\n\r\n        // Update player movement\r\n        if (this.player.isMoving) {\r\n            this.player.update(dt);\r\n        }\r\n\r\n        // Update player buffs\r\n        this.player.updateBuffs(dt);\r\n\r\n        // Check input if not moving (or just finished moving)\r\n        if (!this.player.isMoving) {\r\n            // Check for step-on triggers (e.g. exiting house)\r\n            if (state.currentMap !== 'overworld') {\r\n                const currentMap = this.getCurrentMap(state);\r\n                const tile = currentMap[this.player.gridY][this.player.gridX];\r\n                if (tile === INTERIOR_TILES.DOOR) {\r\n                    this.exitHouse();\r\n                    return;\r\n                }\r\n            }\r\n\r\n            // Poll for continuous smooth movement\r\n            const { x, y } = this.inputManager.moveDirection;\r\n            if (x !== 0 || y !== 0) {\r\n                this.attemptMove(x, y);\r\n            }\r\n            else if (state.destination) {\r\n                this.processPathfinding(state);\r\n            }\r\n        }\r\n\r\n        // Update time\r\n        const newDayStarted = this.timeSystem.update();\r\n        if (newDayStarted) {\r\n            this.showToast(`Day ${this.timeSystem.dayCount}: ${this.timeSystem.getSeasonName()}, ${this.timeSystem.getWeatherMessage()}`);\r\n\r\n            // Handle season change - wither out-of-season crops\r\n            if (this.timeSystem.seasonChanged) {\r\n                this.handleSeasonChange(state);\r\n            }\r\n        }\r\n\r\n        // Update crops (only if not withered)\r\n        for (const key in state.crops) {\r\n            const crop = state.crops[key];\r\n            if (!crop.withered && crop.stage < 100) {\r\n                crop.stage += SEEDS[crop.type].grow;\r\n            }\r\n        }\r\n\r\n        // Update particles\r\n        const view = this.renderer.getViewSize(state.zoom);\r\n        if (this.timeSystem.weather === 'Rain' && state.currentMap === 'overworld') {\r\n            this.particleSystem.addRain(state.camera.x, state.camera.y, view.width, this.timeSystem.season === 3);\r\n        }\r\n        this.particleSystem.update(state.camera.y, view.height);\r\n\r\n        // Update messages\r\n        state.messages = state.messages.filter(m => m.life-- > 0);\r\n\r\n        // Sync state\r\n        setState({\r\n            player: this.player.serialize(),\r\n            pet: this.pet ? this.pet.serialize() : null,\r\n            ...this.timeSystem.serialize(),\r\n            messages: state.messages\r\n        });\r\n\r\n        this.updateUI();\r\n\r\n        // Update Pet\r\n        if (this.pet) {\r\n            this.pet.update(dt, this.player);\r\n\r\n            // Check for intro trigger proximity (use visual coordinates for smoothness)\r\n            if (this.introActive && !this.petIntroTriggered) {\r\n                // Check visual distance (in pixels)\r\n                const dist = Math.hypot(this.pet.visX - this.player.visX, this.pet.visY - this.player.visY);\r\n\r\n                // Trigger when within ~1.2 tiles visually (60 pixels)\r\n                if (dist <= 60) {\r\n                    this.petIntroTriggered = true;\r\n                    this.introActive = false;\r\n                    this.pet.state = 'IDLE';\r\n\r\n                    // Show naming modal\r\n                    const modal = new PetNameModal(this.uiManager, (name) => {\r\n                        this.pet.name = name;\r\n                        this.showToast(`Adopted ${name}!`, '#ffb74d');\r\n                        saveGame();\r\n                    });\r\n                    modal.show();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Process pathfinding to destination\r\n     */\r\n    processPathfinding(state) {\r\n        const dest = state.destination;\r\n        const dx = dest.x - this.player.gridX;\r\n        const dy = dest.y - this.player.gridY;\r\n\r\n        if (dx === 0 && dy === 0) {\r\n            setState({ destination: null });\r\n            return;\r\n        }\r\n\r\n        const sx = Math.sign(dx);\r\n        const sy = Math.sign(dy);\r\n\r\n        const tryMove = (ax, ay) => {\r\n            if (!isSolid(state.map, this.player.gridX + ax, this.player.gridY + ay, state.crops, SEEDS)) {\r\n                this.player.gridX += ax;\r\n                this.player.gridY += ay;\r\n                this.player.facing = { x: ax || 0, y: ay || 0 };\r\n                this.player.isMoving = true;\r\n                return true;\r\n            }\r\n            return false;\r\n        };\r\n\r\n        let moved = false;\r\n        if (Math.abs(dx) >= Math.abs(dy)) {\r\n            if (sx !== 0) moved = tryMove(sx, 0) || (sy !== 0 && tryMove(0, sy));\r\n        } else {\r\n            if (sy !== 0) moved = tryMove(0, sy) || (sx !== 0 && tryMove(sx, 0));\r\n        }\r\n\r\n        if (!moved) {\r\n            this.player.facing = {\r\n                x: Math.abs(dx) >= Math.abs(dy) ? sx : 0,\r\n                y: Math.abs(dy) > Math.abs(dx) ? sy : 0\r\n            };\r\n            setState({ destination: null });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Interact with facing tile\r\n     */\r\n    interact() {\r\n        const state = getState();\r\n        if (state.screen !== 'GAME') return;\r\n\r\n        const { gridX, gridY, facing } = this.player;\r\n        const tx = gridX + facing.x;\r\n        const ty = gridY + facing.y;\r\n\r\n        const currentMap = this.getCurrentMap(state);\r\n        const mapHeight = currentMap.length;\r\n        const mapWidth = currentMap[0]?.length || 0;\r\n\r\n        if (tx < 0 || tx >= mapWidth || ty < 0 || ty >= mapHeight) return;\r\n\r\n        const tile = currentMap[ty][tx];\r\n        const key = `${tx},${ty}`;\r\n        const selectedItem = this.inventory.getSelectedItem();\r\n\r\n        // Check for NPC interaction on the current map\r\n        let currentNpcs = [];\r\n        if (state.currentMap === 'overworld') {\r\n            currentNpcs = state.npcs || [];\r\n        } else {\r\n            const interiorKey = state.currentMap.replace('Interior', '');\r\n            const interior = state.interiors[interiorKey];\r\n            currentNpcs = interior?.npcs || [];\r\n        }\r\n\r\n        if (currentNpcs.length > 0) {\r\n            const npc = currentNpcs.find(n => n.x === tx && n.y === ty);\r\n            if (npc) {\r\n                this.interactWithNPC(npc);\r\n                return;\r\n            }\r\n        }\r\n\r\n        setState({ destination: null });\r\n\r\n        // Interior door - exit to overworld\r\n        if (state.currentMap !== 'overworld' && tile === INTERIOR_TILES.DOOR) {\r\n            this.exitHouse(); // exitHouse now handles returning to previous pos, works for Shop too\r\n            return;\r\n        }\r\n\r\n        // Shop Counter - Open Shop\r\n        if (state.currentMap.includes('shop') && tile === INTERIOR_TILES.COUNTER) {\r\n            setState({ screen: 'SHOP' });\r\n            this.shopModal.show(this.inventory, this.timeSystem.season);\r\n            return;\r\n        }\r\n\r\n        // Interior bed - sleep option\r\n        if (state.currentMap !== 'overworld' && tile === INTERIOR_TILES.BED) {\r\n            this.uiManager.setHouseVisible(true);\r\n            return;\r\n        }\r\n\r\n        // Interior stove - cooking\r\n        if (state.currentMap !== 'overworld' && tile === INTERIOR_TILES.STOVE) {\r\n            setState({ screen: 'COOKING' });\r\n            this.cookingModal.show(this.inventory);\r\n            return;\r\n        }\r\n\r\n        // Only allow outdoor interactions in overworld\r\n        if (state.currentMap !== 'overworld' && !state.currentMap.includes('shop')) {\r\n            return;\r\n        }\r\n\r\n        // Shop (Overworld)\r\n        if (tile === TILES.SHOP) {\r\n            this.enterShop();\r\n            return;\r\n        }\r\n\r\n        // House (Overworld)\r\n        if (tile === TILES.HOUSE) {\r\n            this.enterHouse();\r\n            return;\r\n        }\r\n\r\n        // Old House (Abandoned)\r\n        if (tile === TILES.OLD_HOUSE) {\r\n            this.enterBuilding('old_house');\r\n            return;\r\n        }\r\n\r\n        // Stone/Ore/Boulder\r\n        if (tile === TILES.STONE) {\r\n            this.hitResource(tx, ty, 'STONE');\r\n            return;\r\n        }\r\n        if (tile === TILES.STONE_ORE) {\r\n            this.hitResource(tx, ty, 'ORE');\r\n            return;\r\n        }\r\n        if (tile === TILES.STONE_BOULDER) {\r\n            this.hitResource(tx, ty, 'BOULDER');\r\n            return;\r\n        }\r\n\r\n        // Tree/Oak\r\n        if (tile === TILES.TREE) {\r\n            this.hitResource(tx, ty, 'TREE');\r\n            return;\r\n        }\r\n        if (tile === TILES.TREE_OAK) {\r\n            this.hitResource(tx, ty, 'OAK');\r\n            return;\r\n        }\r\n\r\n        // Clear withered debris back to soil\r\n        if (tile === TILES.WITHERED) {\r\n            if (this.timeSystem.consumeEnergy(2)) {  // Low energy cost to clear\r\n                setTile(state.map, tx, ty, TILES.SOIL);\r\n                this.particleSystem.createBurst(tx * TILE_SIZE + TILE_SIZE / 2, ty * TILE_SIZE + TILE_SIZE / 2, '#8b7355');\r\n                this.showToast('Cleared debris');\r\n            } else {\r\n                this.showToast('Too Exhausted!', '#ef5350');\r\n            }\r\n            return;\r\n        }\r\n\r\n        // Till grass to soil\r\n        if (tile === TILES.GRASS) {\r\n            if (this.timeSystem.consumeEnergy(ENERGY_COST.TILL_SOIL)) {\r\n                setTile(state.map, tx, ty, TILES.SOIL);\r\n                this.particleSystem.createBurst(tx * TILE_SIZE + TILE_SIZE / 2, ty * TILE_SIZE + TILE_SIZE / 2, '#795548');\r\n                this.showToast('Tilled Soil');\r\n            } else {\r\n                this.showToast('Too Exhausted!', '#ef5350');\r\n            }\r\n            return;\r\n        }\r\n\r\n        // Plant seed\r\n        if (tile === TILES.SOIL && !state.crops[key]) {\r\n            if (selectedItem && selectedItem.name.endsWith('_seed')) {\r\n                const type = selectedItem.name.replace('_seed', '');\r\n                const seedData = SEEDS[type];\r\n\r\n                // Check season validity\r\n                if (seedData.seasons && !seedData.seasons.includes(this.timeSystem.season)) {\r\n                    const seasonNames = ['Spring', 'Summer', 'Fall', 'Winter'];\r\n                    const validSeasons = seedData.seasons.map(s => seasonNames[s]).join('/');\r\n                    this.showToast(`${seedData.name}: ${validSeasons} only!`, '#ef5350');\r\n                    return;\r\n                }\r\n\r\n                if (this.timeSystem.consumeEnergy(ENERGY_COST.PLANT)) {\r\n                    this.inventory.removeFromSlot(this.inventory.selected, 1);\r\n                    state.crops[key] = { type, stage: 0 };\r\n                    this.showToast('Planted ' + seedData.name);\r\n                    this.syncInventory();\r\n                    saveGame();\r\n                } else {\r\n                    this.showToast('Too Exhausted!', '#ef5350');\r\n                }\r\n            } else {\r\n                this.showToast('Select Seeds!', '#ffa726');\r\n            }\r\n            return;\r\n        }\r\n\r\n        // Harvest crop\r\n        if (state.crops[key] && state.crops[key].stage >= 100) {\r\n            if (this.timeSystem.consumeEnergy(ENERGY_COST.HARVEST)) {\r\n                const crop = state.crops[key];\r\n                const data = SEEDS[crop.type];\r\n                this.inventory.addItem(crop.type, 1);\r\n\r\n                if (data.isTree) {\r\n                    // Fruit tree - regrows fruit\r\n                    crop.stage = data.regrow;\r\n                    this.showToast('Harvested ' + data.name);\r\n                } else if (data.regrowable) {\r\n                    // Regrowable crop (corn, tomato, etc.) - resets to regrowStage\r\n                    crop.stage = data.regrowStage;\r\n                    this.showToast('Harvested ' + data.name + '!');\r\n                } else {\r\n                    // Single harvest crop - destroyed after harvest\r\n                    if (Math.random() > 0.6) this.inventory.addItem(crop.type + '_seed', 1);\r\n                    delete state.crops[key];\r\n                    setTile(state.map, tx, ty, TILES.SOIL);\r\n                    this.showToast('Got ' + data.name);\r\n                }\r\n\r\n                this.particleSystem.createBurst(tx * TILE_SIZE + TILE_SIZE / 2, ty * TILE_SIZE + TILE_SIZE / 2, data.color);\r\n                this.syncInventory();\r\n                saveGame();\r\n            } else {\r\n                this.showToast('Too Exhausted!', '#ef5350');\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Enter house - switch to interior map\r\n     */\r\n    enterHouse() {\r\n        const state = getState();\r\n        if (state.currentMap !== 'overworld') return; // Fix infinite loop/re-entry\r\n\r\n        this.enterBuilding('house');\r\n    }\r\n\r\n    /**\r\n     * Enter shop - switch to interior map\r\n     */\r\n    enterShop() {\r\n        this.enterBuilding('shop');\r\n    }\r\n\r\n    /**\r\n     * Generic Enter Building\r\n     */\r\n    enterBuilding(type) {\r\n        const state = getState();\r\n        if (state.currentMap !== 'overworld') return; // Fix infinite loop/re-entry\r\n\r\n        // Save current overworld position\r\n        const lastPos = {\r\n            x: this.player.gridX,\r\n            y: this.player.gridY\r\n        };\r\n\r\n        const spawn = getInteriorSpawn(type);\r\n\r\n        let interior = state.interiors[type];\r\n        if (!interior) {\r\n            if (type === 'house') interior = generateHouseInterior();\r\n            else if (type === 'shop') interior = generateShopInterior();\r\n            else if (type === 'old_house') {\r\n                interior = generateOldHouseInterior();\r\n            }\r\n            else interior = generateHouseInterior(); // Fallback\r\n        }\r\n\r\n        setState({\r\n            screen: 'GAME',\r\n            currentMap: type + 'Interior', // e.g. houseInterior, shopInterior, old_houseInterior\r\n            lastOverworldPos: lastPos,\r\n            interiors: { ...state.interiors, [type]: interior },\r\n            player: {\r\n                ...this.player.serialize(),\r\n                gridX: spawn.x,\r\n                gridY: spawn.y,\r\n                visX: spawn.x * TILE_SIZE,\r\n                visY: spawn.y * TILE_SIZE,\r\n                facing: { x: 0, y: -1 } // Face up when entering\r\n            }\r\n        });\r\n\r\n        this.player.gridX = spawn.x;\r\n        this.player.gridY = spawn.y;\r\n        this.player.visX = spawn.x * TILE_SIZE;\r\n        this.player.visY = spawn.y * TILE_SIZE;\r\n        this.player.facing = { x: 0, y: -1 };\r\n\r\n        let name = type.charAt(0).toUpperCase() + type.slice(1);\r\n        if (type === 'old_house') name = 'Old Shack';\r\n        this.showToast(`Entering ${name}...`, '#90caf9');\r\n    }\r\n\r\n    /**\r\n     * Exit building - return to overworld\r\n     */\r\n    exitHouse() {\r\n        const state = getState();\r\n\r\n        // Restore overworld position (in front of door)\r\n        // Adjust logic to place player correctly adjacent to the building if needed\r\n        let lastPos = state.lastOverworldPos || {\r\n            x: Math.floor(MAP_WIDTH / 2),\r\n            y: Math.floor(MAP_HEIGHT / 2)\r\n        };\r\n\r\n        // Simple restoration for now, could be smarter about which side of door\r\n        // Reset player state\r\n        this.player.gridX = lastPos.x;\r\n        this.player.gridY = lastPos.y;\r\n        this.player.visX = lastPos.x * TILE_SIZE;\r\n        this.player.visY = lastPos.y * TILE_SIZE;\r\n        this.player.isMoving = false;\r\n        this.player.facing = { x: 0, y: 1 }; // Face down (away from building)\r\n\r\n        setState({\r\n            screen: 'GAME',\r\n            currentMap: 'overworld',\r\n            player: this.player.serialize()\r\n        });\r\n\r\n        // Ensure we handle building-specific logic if needed\r\n        if (state.currentMap === 'houseInterior') {\r\n            this.uiManager.setHouseVisible(false);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sleep and start new day\r\n     */\r\n    sleep() {\r\n        const state = getState();\r\n        this.timeSystem.startNewDay();\r\n        this.showToast(`Day ${this.timeSystem.dayCount}: ${this.timeSystem.getSeasonName()}, ${this.timeSystem.getWeatherMessage()}`);\r\n\r\n        // Handle season change - wither out-of-season crops\r\n        if (this.timeSystem.seasonChanged) {\r\n            this.handleSeasonChange(state);\r\n        }\r\n\r\n        this.closeHouseModal();\r\n        saveGame();\r\n    }\r\n\r\n    /**\r\n     * Handle season change - wither crops that can't grow in new season\r\n     */\r\n    handleSeasonChange(state) {\r\n        const currentSeason = this.timeSystem.season;\r\n        const seasonNames = ['Spring', 'Summer', 'Fall', 'Winter'];\r\n        let witheredCount = 0;\r\n\r\n        for (const [key, crop] of Object.entries(state.crops)) {\r\n            const data = SEEDS[crop.type];\r\n\r\n            // Skip trees - they persist across seasons\r\n            if (data.isTree) continue;\r\n\r\n            // If crop has seasons defined and is not valid in current season\r\n            if (data.seasons && !data.seasons.includes(currentSeason)) {\r\n                // Parse position\r\n                const [x, y] = key.split(',').map(Number);\r\n\r\n                // Remove the crop\r\n                delete state.crops[key];\r\n\r\n                // Place withered debris on that tile\r\n                setTile(state.map, x, y, TILES.WITHERED);\r\n\r\n                witheredCount++;\r\n            }\r\n        }\r\n\r\n        if (witheredCount > 0) {\r\n            this.showToast(`${witheredCount} crops withered in ${seasonNames[currentSeason]}!`, '#ef5350');\r\n        }\r\n\r\n        saveGame();\r\n    }\r\n\r\n    /**\r\n     * Buy item from shop\r\n     */\r\n    buyItem(seedType) {\r\n        const state = getState();\r\n        const cost = SEEDS[seedType].cost;\r\n\r\n        if (state.money >= cost) {\r\n            if (this.inventory.addItem(seedType + '_seed', 1)) {\r\n                setState({ money: state.money - cost });\r\n                this.syncInventory();\r\n                saveGame();\r\n            }\r\n        } else {\r\n            this.showToast('Need Cash!', '#ef5350');\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sell item\r\n     */\r\n    sellItem(slotIndex, value) {\r\n        const state = getState();\r\n        this.inventory.removeFromSlot(slotIndex, 1);\r\n        setState({ money: state.money + value });\r\n        this.syncInventory();\r\n        saveGame();\r\n    }\r\n\r\n    /**\r\n     * Equip item from inventory\r\n     */\r\n    equipItem(slotIndex) {\r\n        const state = getState();\r\n        const item = this.inventory.slots[slotIndex];\r\n        if (!item) return;\r\n\r\n        const data = ITEM_DATA[item.name] || SEEDS[item.name];\r\n        if (!data || !data.type) return;\r\n\r\n        // Weapon/Equipment logic\r\n        if (data.type === 'weapon') {\r\n            const oldWeapon = this.player.equipment.weapon;\r\n            this.player.equipment.weapon = { ...data, key: item.name };\r\n\r\n            // Remove from inventory\r\n            this.inventory.removeFromSlot(slotIndex, 1);\r\n\r\n            // Return old weapon if exists\r\n            if (oldWeapon) {\r\n                this.inventory.addItem(oldWeapon.key, 1);\r\n            }\r\n\r\n            this.showToast(`Equipped ${data.name}`);\r\n        } else {\r\n            this.showToast(`Cannot equip ${item.name}`);\r\n            return;\r\n        }\r\n\r\n        setState({ player: this.player.serialize() });\r\n        this.syncInventory();\r\n        if (this.uiManager.equipmentModal) this.uiManager.equipmentModal.render();\r\n        saveGame();\r\n    }\r\n\r\n    /**\r\n     * Attack with equipped weapon\r\n     */\r\n    attack() {\r\n        if (!this.player.equipment.weapon) return;\r\n        if (this.attackCooldown > 0) return;\r\n\r\n        this.attackCooldown = 20; // ~0.3s at 60fps\r\n        this.player.startAttack(); // Trigger visual animation\r\n\r\n        // Visual effect\r\n        const { gridX, gridY, facing } = this.player;\r\n        const tx = gridX + facing.x;\r\n        const ty = gridY + facing.y;\r\n\r\n        this.particleSystem.createBurst(\r\n            tx * TILE_SIZE + TILE_SIZE / 2,\r\n            ty * TILE_SIZE + TILE_SIZE / 2,\r\n            '#ffffff', 10\r\n        );\r\n\r\n        this.showToast(\"Hyah!\");\r\n\r\n        // Future: Check for enemies in range\r\n    }\r\n\r\n    /**\r\n     * Close shop\r\n     */\r\n    closeShop() {\r\n        setState({ screen: 'GAME' });\r\n        this.shopModal.hide();\r\n    }\r\n\r\n    /**\r\n     * Consume a food item from inventory\r\n     */\r\n    consumeFoodItem(slotIdx) {\r\n        const item = this.inventory.slots[slotIdx];\r\n        if (!item) return;\r\n\r\n        const consumable = CONSUMABLES[item.name];\r\n        if (!consumable) {\r\n            this.showToast('Cannot eat this!', '#ef5350');\r\n            return;\r\n        }\r\n\r\n        // Restore energy\r\n        this.timeSystem.energy = Math.min(\r\n            this.timeSystem.energy + consumable.energy,\r\n            this.timeSystem.maxEnergy\r\n        );\r\n\r\n        // Remove item\r\n        this.inventory.removeFromSlot(slotIdx, 1);\r\n\r\n        // Apply buff if any\r\n        if (consumable.buff) {\r\n            this.player.applyBuff(consumable.buff);\r\n            const buffName = consumable.buff.type.replace(/([A-Z])/g, ' $1').trim();\r\n            this.showToast(`${buffName} active!`, '#4fc3f7');\r\n        }\r\n\r\n        this.showToast(`+${consumable.energy} Energy`, '#81c784');\r\n        this.syncInventory();\r\n        saveGame();\r\n    }\r\n\r\n    /**\r\n     * Reset game data\r\n     */\r\n    resetGameData() {\r\n        resetGame();\r\n        location.reload();\r\n    }\r\n\r\n    /**\r\n     * Sync inventory to state\r\n     */\r\n    syncInventory() {\r\n        setState({ inventory: this.inventory.serialize() });\r\n    }\r\n\r\n    /**\r\n     * Show toast message\r\n     */\r\n    showToast(text, color = 'white') {\r\n        const state = getState();\r\n        state.messages.push({ text, color, life: 60 });\r\n    }\r\n\r\n    /**\r\n     * Update UI\r\n     */\r\n    updateUI() {\r\n        const state = getState();\r\n\r\n        this.uiManager.renderInventory(this.inventory);\r\n        this.uiManager.updateStats({\r\n            money: state.money,\r\n            day: this.timeSystem.dayCount,\r\n            season: this.timeSystem.season,\r\n            weather: this.timeSystem.weather,\r\n            energy: this.timeSystem.energy,\r\n            maxEnergy: this.timeSystem.maxEnergy,\r\n            timeString: this.timeSystem.getTimeString(),\r\n            hp: this.player.hp,\r\n            maxHp: this.player.maxHp\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Draw the game\r\n     */\r\n    draw() {\r\n        const state = getState();\r\n        if (state.screen === 'CREATOR') return;\r\n\r\n        this.renderer.clear();\r\n\r\n        // Update camera\r\n        const currentMap = this.getCurrentMap(state);\r\n        const mapHeight = currentMap.length;\r\n        const mapWidth = currentMap[0]?.length || 0;\r\n\r\n        const camera = this.renderer.updateCamera(this.player.visX, this.player.visY, state.zoom, mapWidth, mapHeight);\r\n        setState({ camera });\r\n\r\n        // Begin world drawing\r\n        this.renderer.beginWorldDraw(camera, state.zoom);\r\n\r\n        // Calculate Darkness (0.0=Day, 0.7=Night)\r\n        const hour = this.timeSystem.hour;\r\n        let darkness = 0;\r\n        if (hour >= 18 || hour < 6) {\r\n            // Transition sunset/sunrise\r\n            if (hour >= 18 && hour < 22) darkness = (hour - 18) / 4 * 0.7;\r\n            else if (hour >= 22 || hour < 4) darkness = 0.7;\r\n            else if (hour >= 4 && hour < 6) darkness = (1 - (hour - 4) / 2) * 0.7;\r\n        }\r\n\r\n        const range = this.renderer.getVisibleTileRange(camera, state.zoom);\r\n\r\n        // --- Pass 1: Ground Tiles ---\r\n        for (let y = range.startY; y < range.endY; y++) {\r\n            for (let x = range.startX; x < range.endX; x++) {\r\n                if (x < 0 || x >= mapWidth || y < 0 || y >= mapHeight) continue;\r\n                const tile = currentMap[y][x];\r\n\r\n                if (state.currentMap === 'overworld') {\r\n                    // Always draw grass as base\r\n                    this.tileRenderer.drawTile(TILES.GRASS, x, y, this.timeSystem.season, currentMap);\r\n\r\n                    if (tile === TILES.SOIL || tile === TILES.WITHERED) {\r\n                        this.tileRenderer.drawTile(tile, x, y, this.timeSystem.season, currentMap);\r\n                    }\r\n                } else {\r\n                    if (tile === INTERIOR_TILES.FLOOR || tile === INTERIOR_TILES.RUG || tile === INTERIOR_TILES.DOOR) {\r\n                        this.tileRenderer.drawInteriorTile(tile, x, y);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // --- Pass 2: Sorted Standing Objects & Entities ---\r\n        // We draw row by row. For each row, we draw standing tiles, then entities.\r\n        for (let y = range.startY; y < range.endY; y++) {\r\n            // 1. Standing Tiles for this row\r\n            for (let x = range.startX; x < range.endX; x++) {\r\n                if (x < 0 || x >= mapWidth || y < 0 || y >= mapHeight) continue;\r\n                const tile = currentMap[y][x];\r\n\r\n                if (state.currentMap === 'overworld') {\r\n                    // Only draw NOT ground tiles (Trees, Buildings)\r\n                    if (tile !== TILES.GRASS && tile !== TILES.SOIL && tile !== TILES.WITHERED) {\r\n                        // For buildings, we only want to draw the full building when we hit the BOTTOM row of its 3x3 footprint \r\n                        // so that players standing \"behind\" it (in higher rows) are drawn before it.\r\n                        // However, isTopLeftCorner logic draws it all. Let's adjust for depth sorting.\r\n                        // Simplification: just draw it. True y-sorting for multi-tile objects is tricky but this helps.\r\n                        this.tileRenderer.drawTile(tile, x, y, this.timeSystem.season, currentMap);\r\n                    }\r\n                    const crop = state.crops[`${x},${y}`];\r\n                    if (crop) this.tileRenderer.drawCrop(crop, x, y);\r\n                } else {\r\n                    if (tile !== INTERIOR_TILES.FLOOR && tile !== INTERIOR_TILES.RUG && tile !== INTERIOR_TILES.DOOR) {\r\n                        this.tileRenderer.drawInteriorTile(tile, x, y);\r\n                    }\r\n                }\r\n            }\r\n\r\n            // 2. Entities whose \"pivot\" is in this row\r\n            // pivot is approx visY + TILE_SIZE\r\n            const rowBottomY = (y + 1) * TILE_SIZE;\r\n            const rowTopY = y * TILE_SIZE;\r\n\r\n            // NPCs\r\n            // Draw NPCs for the current map\r\n            const currentNpcs = (state.currentMap === 'overworld')\r\n                ? state.npcs\r\n                : (state.interiors[state.currentMap.replace('Interior', '')]?.npcs || []);\r\n\r\n            if (currentNpcs) {\r\n                currentNpcs.forEach(npc => {\r\n                    const npcBottomY = (npc.y + 1) * TILE_SIZE;\r\n                    if (npcBottomY > rowTopY && npcBottomY <= rowBottomY) {\r\n                        this.tileRenderer.drawNPC(this.renderer.ctx, npc.x * TILE_SIZE, npc.y * TILE_SIZE, npc.id);\r\n                    }\r\n                });\r\n            }\r\n\r\n            // Pet\r\n            if (this.pet && state.currentMap === 'overworld') {\r\n                const petBottomY = this.pet.visY + TILE_SIZE;\r\n                if (petBottomY > rowTopY && petBottomY <= rowBottomY) {\r\n                    this.pet.draw(this.renderer.ctx, this.pet.visX + TILE_SIZE / 2, this.pet.visY + TILE_SIZE / 2);\r\n                }\r\n            }\r\n\r\n            // Player\r\n            const playerBottomY = this.player.visY + TILE_SIZE;\r\n            if (playerBottomY > rowTopY && playerBottomY <= rowBottomY) {\r\n                this.player.draw(this.renderer.ctx, this.player.visX + TILE_SIZE / 2, this.player.visY + TILE_SIZE / 2);\r\n            }\r\n        }\r\n\r\n        // --- Post-Pass: Indicators & Effects ---\r\n        if (state.destination) {\r\n            this.renderer.drawDestination(state.destination);\r\n        }\r\n\r\n        // --- Pass 4: Global Illumination & Lighting ---\r\n        if (darkness > 0) {\r\n            const lights = [];\r\n\r\n            // Player Light\r\n            const screenPos = {\r\n                x: (this.player.visX + TILE_SIZE / 2 - camera.x) * state.zoom,\r\n                y: (this.player.visY + TILE_SIZE / 2 - camera.y) * state.zoom\r\n            };\r\n            lights.push({ x: screenPos.x, y: screenPos.y, radius: 150 * state.zoom });\r\n\r\n            // Building Lights (Only if on screen)\r\n            if (state.currentMap === 'overworld') {\r\n                // Find visible buildings and add lights to windows\r\n                for (let y = range.startY; y < range.endY; y++) {\r\n                    for (let x = range.startX; x < range.endX; x++) {\r\n                        if (x < 0 || x >= mapWidth || y < 0 || y >= mapHeight) continue;\r\n                        const tile = currentMap[y][x];\r\n\r\n                        if (tile === TILES.HOUSE || tile === TILES.SHOP || tile === TILES.OLD_HOUSE) {\r\n                            if (this.tileRenderer.isBottomLeftCorner(currentMap, x, y, tile)) {\r\n                                const bx = (x * TILE_SIZE - camera.x) * state.zoom;\r\n                                const by = (y * TILE_SIZE - camera.y) * state.zoom;\r\n\r\n                                // Window positions relative to building bottom-left\r\n                                if (tile === TILES.HOUSE) {\r\n                                    lights.push({ x: bx + 50 * state.zoom, y: by - 40 * state.zoom, radius: 60 * state.zoom });\r\n                                    lights.push({ x: bx + 100 * state.zoom, y: by - 40 * state.zoom, radius: 60 * state.zoom });\r\n                                } else if (tile === TILES.SHOP) {\r\n                                    lights.push({ x: bx + 40 * state.zoom, y: by - 30 * state.zoom, radius: 80 * state.zoom });\r\n                                    lights.push({ x: bx + 110 * state.zoom, y: by - 30 * state.zoom, radius: 80 * state.zoom });\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            this.renderer.drawLightingOverlay(darkness, lights);\r\n        }\r\n\r\n        this.renderer.drawFacingIndicator(this.player.gridX, this.player.gridY, this.player.facing);\r\n        this.particleSystem.drawParticles(this.renderer.ctx);\r\n\r\n        if (this.timeSystem.weather === 'Rain' && state.currentMap === 'overworld') {\r\n            this.particleSystem.drawRain(this.renderer.ctx, this.timeSystem.season === 3);\r\n        }\r\n\r\n        this.renderer.endWorldDraw();\r\n\r\n        // Draw overlays\r\n        if (this.timeSystem.weather === 'Rain' && state.currentMap === 'overworld') {\r\n            this.renderer.drawRainOverlay();\r\n        }\r\n\r\n        // Legacy Night overlay removed in favor of Pass 4 Lighting\r\n        this.renderer.drawMessages(state.messages);\r\n    }\r\n\r\n    /**\r\n     * Get current map array based on state\r\n     */\r\n    getCurrentMap(state) {\r\n        if (state.currentMap === 'overworld') {\r\n            return state.map;\r\n        } else {\r\n            const interiorKey = state.currentMap.replace('Interior', '');\r\n            const interior = state.interiors[interiorKey];\r\n            return interior ? (interior.map || interior) : state.map;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Check if a tile is solid (blocks movement)\r\n     */\r\n    isTileSolid(state, x, y) {\r\n        const currentMap = this.getCurrentMap(state);\r\n\r\n        if (y < 0 || y >= currentMap.length || x < 0 || x >= currentMap[0].length) {\r\n            return true;\r\n        }\r\n\r\n        const tile = currentMap[y][x];\r\n\r\n        // Check for NPC collision on the current map\r\n        let currentNpcs = [];\r\n        if (state.currentMap === 'overworld') {\r\n            currentNpcs = state.npcs || [];\r\n        } else {\r\n            const interiorKey = state.currentMap.replace('Interior', '');\r\n            const interior = state.interiors[interiorKey];\r\n            currentNpcs = interior?.npcs || [];\r\n        }\r\n\r\n        if (currentNpcs.some(npc => npc.x === x && npc.y === y)) {\r\n            return true;\r\n        }\r\n\r\n        // Interior tiles\r\n        if (state.currentMap !== 'overworld') {\r\n            return isInteriorSolid(tile);\r\n        }\r\n\r\n        return isSolid(state.map, x, y, state.crops, SEEDS);\r\n    }\r\n\r\n    /**\r\n     * Override draw to support interior maps\r\n     */\r\n    drawCurrentMap(state, range) {\r\n        const currentMap = this.getCurrentMap(state);\r\n        const mapHeight = currentMap.length;\r\n        const mapWidth = currentMap[0]?.length || 0;\r\n\r\n        for (let y = range.startY; y < range.endY; y++) {\r\n            for (let x = range.startX; x < range.endX; x++) {\r\n                if (x < 0 || x >= mapWidth || y < 0 || y >= mapHeight) continue;\r\n\r\n                const tile = currentMap[y][x];\r\n\r\n                if (state.currentMap === 'overworld') {\r\n                    this.tileRenderer.drawTile(tile, x, y, this.timeSystem.season, state.map);\r\n\r\n                    const crop = state.crops[`${x},${y}`];\r\n                    if (crop) {\r\n                        this.tileRenderer.drawCrop(crop, x, y);\r\n                    }\r\n                } else {\r\n                    this.tileRenderer.drawInteriorTile(tile, x, y);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Hit a resource tile (tree/stone) with Durability tracking\r\n     */\r\n    hitResource(x, y, resourceTypeKey) {\r\n        const state = getState();\r\n        const resourceType = RESOURCE_TYPES[resourceTypeKey];\r\n\r\n        if (!resourceType) {\r\n            console.warn('Unknown resource type:', resourceTypeKey);\r\n            return;\r\n        }\r\n\r\n        // Check if resource has toughness or hp defined (handle legacy/reload states)\r\n        const toughness = resourceType.toughness !== undefined ? resourceType.toughness : (resourceType.hp || 1);\r\n\r\n        // Check energy\r\n        if (!this.timeSystem.consumeEnergy(resourceType.energyCost)) {\r\n            this.showToast('Too Exhausted!', '#ef5350');\r\n            return;\r\n        }\r\n\r\n        const key = `${x},${y}`;\r\n\r\n        // Get or initialize Durability for this tile\r\n        // We use 'resourceHP' in state for backward compatibility but conceptually it's durability\r\n        let currentDurability = state.resourceHP[key];\r\n        if (currentDurability === undefined) {\r\n            currentDurability = toughness;\r\n        }\r\n\r\n        // Hit the resource\r\n        currentDurability -= 1;\r\n\r\n        // Particle effect on hit\r\n        this.particleSystem.createBurst(\r\n            x * TILE_SIZE + TILE_SIZE / 2,\r\n            y * TILE_SIZE + TILE_SIZE / 2,\r\n            resourceType.color\r\n        );\r\n\r\n        if (currentDurability <= 0) {\r\n            // Resource destroyed - give items\r\n            for (const [item, count] of Object.entries(resourceType.yield)) {\r\n                this.inventory.addItem(item, count);\r\n            }\r\n\r\n            // Build toast message\r\n            const drops = Object.entries(resourceType.yield)\r\n                .map(([item, count]) => `+${count} ${item.charAt(0).toUpperCase() + item.slice(1)}`)\r\n                .join(', ');\r\n            this.showToast(drops, '#81c784');\r\n\r\n            // Clear the tile\r\n            setTile(state.map, x, y, TILES.GRASS);\r\n\r\n            // Remove durability tracking\r\n            delete state.resourceHP[key];\r\n            setState({ resourceHP: { ...state.resourceHP } });\r\n        } else {\r\n            // Resource damaged but not destroyed\r\n            this.showToast('Cracked!', '#ffa726'); // Visual/Text feedback without \"HP\"\r\n\r\n            // Save Durability state\r\n            state.resourceHP[key] = currentDurability;\r\n            setState({ resourceHP: { ...state.resourceHP } });\r\n        }\r\n\r\n        this.syncInventory();\r\n        saveGame();\r\n    }\r\n\r\n\r\n    /**\r\n     * Interact with NPC\r\n     */\r\n    interactWithNPC(npc) {\r\n        const state = getState();\r\n\r\n        if (npc.id === NPC_IDS.OLD_MAN) {\r\n            if (!state.player.questFlags || !state.player.questFlags.hasSword) {\r\n                this.uiManager.showDialogue(\r\n                    \"It's dangerous to go alone! Take this.\",\r\n                    () => {\r\n                        this.inventory.addItem('WOODEN_SWORD', 1);\r\n                        if (!this.player.questFlags) this.player.questFlags = {};\r\n                        this.player.questFlags.hasSword = true;\r\n                        this.showToast(\"Got Wooden Sword!\", '#ffd700');\r\n                        setState({ player: this.player.serialize() });\r\n                        this.syncInventory();\r\n                        saveGame();\r\n                    }\r\n                );\r\n            } else {\r\n                this.uiManager.showDialogue(\"Be careful out there, young farmer.\");\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nexport default Game;\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\njyti\\Desktop\\Google-Antigravity\\2d-farming-game\\src\\game\\constants.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\njyti\\Desktop\\Google-Antigravity\\2d-farming-game\\src\\game\\state.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\njyti\\Desktop\\Google-Antigravity\\2d-farming-game\\src\\input\\InputManager.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\njyti\\Desktop\\Google-Antigravity\\2d-farming-game\\src\\main.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\njyti\\Desktop\\Google-Antigravity\\2d-farming-game\\src\\rendering\\Renderer.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'MAP_WIDTH' is defined but never used.","line":6,"column":21,"nodeType":"Identifier","messageId":"unusedVar","endLine":6,"endColumn":30,"suggestions":[{"messageId":"removeVar","data":{"varName":"MAP_WIDTH"},"fix":{"range":[105,116],"text":""},"desc":"Remove unused variable 'MAP_WIDTH'."}]},{"ruleId":"no-unused-vars","severity":1,"message":"'MAP_HEIGHT' is defined but never used.","line":6,"column":32,"nodeType":"Identifier","messageId":"unusedVar","endLine":6,"endColumn":42,"suggestions":[{"messageId":"removeVar","data":{"varName":"MAP_HEIGHT"},"fix":{"range":[116,128],"text":""},"desc":"Remove unused variable 'MAP_HEIGHT'."}]},{"ruleId":"no-unused-vars","severity":1,"message":"'SEASON_COLORS' is defined but never used.","line":6,"column":44,"nodeType":"Identifier","messageId":"unusedVar","endLine":6,"endColumn":57,"suggestions":[{"messageId":"removeVar","data":{"varName":"SEASON_COLORS"},"fix":{"range":[128,143],"text":""},"desc":"Remove unused variable 'SEASON_COLORS'."}]},{"ruleId":"no-unused-vars","severity":1,"message":"'SEASONS' is defined but never used.","line":6,"column":59,"nodeType":"Identifier","messageId":"unusedVar","endLine":6,"endColumn":66,"suggestions":[{"messageId":"removeVar","data":{"varName":"SEASONS"},"fix":{"range":[143,152],"text":""},"desc":"Remove unused variable 'SEASONS'."}]},{"ruleId":"no-unused-vars","severity":1,"message":"'gridX' is defined but never used. Allowed unused args must match /^_/u.","line":219,"column":25,"nodeType":"Identifier","messageId":"unusedVar","endLine":219,"endColumn":30,"suggestions":[{"messageId":"removeVar","data":{"varName":"gridX"},"fix":{"range":[6493,6499],"text":""},"desc":"Remove unused variable 'gridX'."}]},{"ruleId":"no-unused-vars","severity":1,"message":"'gridY' is defined but never used. Allowed unused args must match /^_/u.","line":219,"column":32,"nodeType":"Identifier","messageId":"unusedVar","endLine":219,"endColumn":37,"suggestions":[{"messageId":"removeVar","data":{"varName":"gridY"},"fix":{"range":[6498,6505],"text":""},"desc":"Remove unused variable 'gridY'."}]},{"ruleId":"no-unused-vars","severity":1,"message":"'facing' is defined but never used. Allowed unused args must match /^_/u.","line":219,"column":39,"nodeType":"Identifier","messageId":"unusedVar","endLine":219,"endColumn":45,"suggestions":[{"messageId":"removeVar","data":{"varName":"facing"},"fix":{"range":[6505,6513],"text":""},"desc":"Remove unused variable 'facing'."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Main Renderer\r\n * Handles canvas setup, camera, and draw orchestration\r\n */\r\n\r\nimport { TILE_SIZE, MAP_WIDTH, MAP_HEIGHT, SEASON_COLORS, SEASONS, PALETTE } from '../game/constants.js';\r\n\r\nexport class Renderer {\r\n    constructor(canvas) {\r\n        this.canvas = canvas;\r\n        this.ctx = canvas.getContext('2d');\r\n        this.resize();\r\n\r\n        window.addEventListener('resize', () => this.resize());\r\n    }\r\n\r\n    /**\r\n     * Resize canvas to window size\r\n     */\r\n    resize() {\r\n        this.canvas.width = window.innerWidth;\r\n        this.canvas.height = window.innerHeight;\r\n    }\r\n\r\n    /**\r\n     * Get canvas dimensions\r\n     */\r\n    getSize() {\r\n        return {\r\n            width: this.canvas.width,\r\n            height: this.canvas.height\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Calculate view dimensions based on zoom\r\n     */\r\n    getViewSize(zoom) {\r\n        return {\r\n            width: this.canvas.width / zoom,\r\n            height: this.canvas.height / zoom\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Update camera position to follow player\r\n     */\r\n    updateCamera(playerVisX, playerVisY, zoom, mapWidth, mapHeight) {\r\n        const view = this.getViewSize(zoom);\r\n        const worldWidth = mapWidth * TILE_SIZE;\r\n        const worldHeight = mapHeight * TILE_SIZE;\r\n\r\n        let camX = playerVisX + TILE_SIZE / 2 - view.width / 2;\r\n        let camY = playerVisY + TILE_SIZE / 2 - view.height / 2;\r\n\r\n        // Clamp to map bounds or center if smaller than view\r\n        if (worldWidth <= view.width) {\r\n            camX = (worldWidth - view.width) / 2;\r\n        } else {\r\n            camX = Math.max(0, Math.min(camX, worldWidth - view.width));\r\n        }\r\n\r\n        if (worldHeight <= view.height) {\r\n            camY = (worldHeight - view.height) / 2;\r\n        } else {\r\n            camY = Math.max(0, Math.min(camY, worldHeight - view.height));\r\n        }\r\n\r\n        return { x: camX, y: camY };\r\n    }\r\n\r\n    /**\r\n     * Get visible tile range for culling\r\n     */\r\n    getVisibleTileRange(camera, zoom) {\r\n        const view = this.getViewSize(zoom);\r\n\r\n        return {\r\n            startX: Math.floor(camera.x / TILE_SIZE),\r\n            endX: Math.ceil((camera.x + view.width) / TILE_SIZE) + 1,\r\n            startY: Math.floor(camera.y / TILE_SIZE),\r\n            endY: Math.ceil((camera.y + view.height) / TILE_SIZE) + 1\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Clear the canvas\r\n     */\r\n    clear() {\r\n        this.ctx.fillStyle = '#121212';\r\n        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\r\n    }\r\n\r\n    /**\r\n     * Begin world space drawing\r\n     */\r\n    beginWorldDraw(camera, zoom) {\r\n        this.ctx.save();\r\n        this.ctx.scale(zoom, zoom);\r\n        // Round camera coordinates to prevent sub-pixel gaps between tiles\r\n        this.ctx.translate(Math.floor(-camera.x), Math.floor(-camera.y));\r\n    }\r\n\r\n    /**\r\n     * End world space drawing\r\n     */\r\n    endWorldDraw() {\r\n        this.ctx.restore();\r\n    }\r\n\r\n    /**\r\n     * Draw rain overlay\r\n     */\r\n    drawRainOverlay() {\r\n        this.ctx.fillStyle = 'rgba(0, 0, 20, 0.2)';\r\n        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\r\n    }\r\n\r\n    // Legacy drawNightOverlay removed\r\n\r\n    /**\r\n     * Draw toast messages\r\n     */\r\n    /**\r\n     * Draw lighting overlay with point lights\r\n     */\r\n    drawLightingOverlay(darkness, lights = []) {\r\n        if (darkness <= 0) return;\r\n\r\n        // Use an offscreen canvas for the lighting multiply pass if needed,\r\n        // but for simple cases we can just fill a rect with multiply blend mode.\r\n        // However, to support 'punch-through' lights, we need a separate buffer.\r\n\r\n        if (!this.lightingCanvas) {\r\n            this.lightingCanvas = document.createElement('canvas');\r\n            this.lightingCtx = this.lightingCanvas.getContext('2d');\r\n        }\r\n\r\n        this.lightingCanvas.width = this.canvas.width;\r\n        this.lightingCanvas.height = this.canvas.height;\r\n\r\n        const lctx = this.lightingCtx;\r\n\r\n        // Fill with darkness\r\n        const nightColor = PALETTE.sky_night || '#1a1c2c';\r\n        lctx.fillStyle = nightColor;\r\n        lctx.globalAlpha = darkness;\r\n        lctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\r\n        lctx.globalAlpha = 1.0;\r\n\r\n        // Punch out lights\r\n        lctx.globalCompositeOperation = 'destination-out';\r\n\r\n        for (const light of lights) {\r\n            const rad = light.radius || 100;\r\n            const grad = lctx.createRadialGradient(\r\n                light.x, light.y, 0,\r\n                light.x, light.y, rad\r\n            );\r\n            grad.addColorStop(0, 'rgba(255, 255, 255, 1.0)');\r\n            grad.addColorStop(1, 'rgba(255, 255, 255, 0)');\r\n\r\n            lctx.fillStyle = grad;\r\n            lctx.beginPath();\r\n            lctx.arc(light.x, light.y, rad, 0, Math.PI * 2);\r\n            lctx.fill();\r\n        }\r\n\r\n        // Draw the lighting buffer back to main canvas using multiply\r\n        this.ctx.globalAlpha = 1.0;\r\n        this.ctx.globalCompositeOperation = 'multiply';\r\n        this.ctx.drawImage(this.lightingCanvas, 0, 0);\r\n        this.ctx.globalCompositeOperation = 'source-over';\r\n    }\r\n\r\n    drawMessages(messages) {\r\n        let y = this.canvas.height - 180;\r\n\r\n        this.ctx.textAlign = 'center';\r\n        this.ctx.font = 'bold 16px sans-serif';\r\n\r\n        for (const msg of messages) {\r\n            this.ctx.globalAlpha = Math.min(1, msg.life / 40);\r\n\r\n            const textWidth = this.ctx.measureText(msg.text).width + 20;\r\n\r\n            // Background\r\n            this.ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';\r\n            this.ctx.fillRect(this.canvas.width / 2 - textWidth / 2, y - 15, textWidth, 22);\r\n\r\n            // Text\r\n            this.ctx.fillStyle = msg.color;\r\n            this.ctx.fillText(msg.text, this.canvas.width / 2, y);\r\n\r\n            y -= 30;\r\n        }\r\n\r\n        this.ctx.globalAlpha = 1;\r\n        this.ctx.textAlign = 'left';\r\n    }\r\n\r\n    /**\r\n     * Draw movement destination indicator\r\n     */\r\n    drawDestination(destination) {\r\n        const dx = destination.x * TILE_SIZE + TILE_SIZE / 2;\r\n        const dy = destination.y * TILE_SIZE + TILE_SIZE / 2;\r\n\r\n        this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';\r\n        this.ctx.lineWidth = 2;\r\n        this.ctx.beginPath();\r\n        this.ctx.arc(dx, dy, 10, 0, Math.PI * 2);\r\n        this.ctx.stroke();\r\n    }\r\n\r\n    /**\r\n     * Draw facing tile indicator\r\n     */\r\n    drawFacingIndicator(gridX, gridY, facing) {\r\n        // Yellow square indicator removed as requested\r\n    }\r\n\r\n    /**\r\n     * Convert screen coordinates to world tile\r\n     */\r\n    screenToTile(screenX, screenY, camera, zoom) {\r\n        const worldX = (screenX / zoom) + camera.x;\r\n        const worldY = (screenY / zoom) + camera.y;\r\n\r\n        return {\r\n            x: Math.floor(worldX / TILE_SIZE),\r\n            y: Math.floor(worldY / TILE_SIZE)\r\n        };\r\n    }\r\n}\r\n\r\nexport default Renderer;\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\njyti\\Desktop\\Google-Antigravity\\2d-farming-game\\src\\rendering\\TileRenderer.js","messages":[{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":52,"column":17,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":52,"endColumn":57,"suggestions":[{"messageId":"addBrackets","fix":{"range":[1550,2479],"text":"{ const gSeed = (x * 12345) ^ (y * 67890);\r\n                const gRand = (Math.abs(gSeed) % 10) / 100; // 0.0 to 0.1\r\n                ctx.fillStyle = colors.grass;\r\n\r\n                // Slightly darken/lighten\r\n                if (gRand > 0.05) {\r\n                    ctx.globalAlpha = 0.9 + gRand; // 0.95 to 1.05 influence... wait globalAlpha is 0-1\r\n                    // Better to just adjust the color slightly\r\n                    ctx.fillStyle = colors.grass; // Placeholder for now, coloring is fixed\r\n                }\r\n\r\n                ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);\r\n\r\n                // Add a very subtle overlay for variety\r\n                ctx.fillStyle = 'rgba(0,0,0,' + (gRand * 0.05) + ')';\r\n                ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);\r\n\r\n                // Procedural Decoration (Tufts, Flowers)\r\n                this.drawGrassDecoration(ctx, px, py, x, y);\r\n                break; }"},"desc":"Add {} brackets around the case block."}]},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":53,"column":17,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":53,"endColumn":60,"suggestions":[{"messageId":"addBrackets","fix":{"range":[1550,2479],"text":"{ const gSeed = (x * 12345) ^ (y * 67890);\r\n                const gRand = (Math.abs(gSeed) % 10) / 100; // 0.0 to 0.1\r\n                ctx.fillStyle = colors.grass;\r\n\r\n                // Slightly darken/lighten\r\n                if (gRand > 0.05) {\r\n                    ctx.globalAlpha = 0.9 + gRand; // 0.95 to 1.05 influence... wait globalAlpha is 0-1\r\n                    // Better to just adjust the color slightly\r\n                    ctx.fillStyle = colors.grass; // Placeholder for now, coloring is fixed\r\n                }\r\n\r\n                ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);\r\n\r\n                // Add a very subtle overlay for variety\r\n                ctx.fillStyle = 'rgba(0,0,0,' + (gRand * 0.05) + ')';\r\n                ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);\r\n\r\n                // Procedural Decoration (Tufts, Flowers)\r\n                this.drawGrassDecoration(ctx, px, py, x, y);\r\n                break; }"},"desc":"Add {} brackets around the case block."}]},{"ruleId":"no-unreachable","severity":2,"message":"Unreachable code.","line":865,"column":17,"nodeType":"ExpressionStatement","messageId":"unreachableCode","endLine":866,"endColumn":23}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Tile Renderer\r\n * Draws tiles, buildings, and crops\r\n */\r\n\r\nimport { TILE_SIZE, TILES, INTERIOR_TILES, SEEDS, SEASON_COLORS, SEASONS, PALETTE } from '../game/constants.js';\r\n\r\nexport class TileRenderer {\r\n    constructor(ctx) {\r\n        this.ctx = ctx;\r\n    }\r\n\r\n    /**\r\n     * Get season colors\r\n     */\r\n    getSeasonColors(seasonIndex) {\r\n        const seasonName = SEASONS[seasonIndex] || 'Spring';\r\n        return SEASON_COLORS[seasonName] || SEASON_COLORS.Spring;\r\n    }\r\n\r\n    /**\r\n     * Check if this tile is the top-left corner of a building\r\n     */\r\n    isTopLeftCorner(map, x, y, tileType) {\r\n        const hasAbove = y > 0 && map[y - 1] && map[y - 1][x] === tileType;\r\n        const hasLeft = x > 0 && map[y][x - 1] === tileType;\r\n        return !hasAbove && !hasLeft;\r\n    }\r\n\r\n    /**\r\n     * Check if this tile is the bottom-left corner of a building\r\n     * Used for y-sorting.\r\n     */\r\n    isBottomLeftCorner(map, x, y, tileType) {\r\n        const hasBelow = y < map.length - 1 && map[y + 1] && map[y + 1][x] === tileType;\r\n        const hasLeft = x > 0 && map[y][x - 1] === tileType;\r\n        return !hasBelow && !hasLeft;\r\n    }\r\n\r\n    /**\r\n     * Draw a single tile\r\n     */\r\n    drawTile(tileType, x, y, seasonIndex, map) {\r\n        const ctx = this.ctx;\r\n        const px = x * TILE_SIZE;\r\n        const py = y * TILE_SIZE;\r\n        const colors = this.getSeasonColors(seasonIndex);\r\n\r\n        switch (tileType) {\r\n            case TILES.GRASS:\r\n                // Subtle color variation (Wang-like)\r\n                const gSeed = (x * 12345) ^ (y * 67890);\r\n                const gRand = (Math.abs(gSeed) % 10) / 100; // 0.0 to 0.1\r\n                ctx.fillStyle = colors.grass;\r\n\r\n                // Slightly darken/lighten\r\n                if (gRand > 0.05) {\r\n                    ctx.globalAlpha = 0.9 + gRand; // 0.95 to 1.05 influence... wait globalAlpha is 0-1\r\n                    // Better to just adjust the color slightly\r\n                    ctx.fillStyle = colors.grass; // Placeholder for now, coloring is fixed\r\n                }\r\n\r\n                ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);\r\n\r\n                // Add a very subtle overlay for variety\r\n                ctx.fillStyle = 'rgba(0,0,0,' + (gRand * 0.05) + ')';\r\n                ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);\r\n\r\n                // Procedural Decoration (Tufts, Flowers)\r\n                this.drawGrassDecoration(ctx, px, py, x, y);\r\n                break;\r\n\r\n            case TILES.SOIL:\r\n                this.drawAutotiledSoil(ctx, px, py, x, y, map);\r\n                break;\r\n\r\n            case TILES.TREE:\r\n                // Shadow\r\n                ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';\r\n                ctx.beginPath();\r\n                ctx.ellipse(px + 25, py + 45, 15, 6, 0, 0, Math.PI * 2);\r\n                ctx.fill();\r\n                // Trunk\r\n                ctx.fillStyle = PALETTE.wood;\r\n                ctx.fillRect(px + 21, py + 15, 8, 30);\r\n                // Lower Leaves\r\n                ctx.fillStyle = colors.tree;\r\n                ctx.beginPath();\r\n                ctx.arc(px + 25, py + 5, 20, 0, Math.PI * 2);\r\n                ctx.fill();\r\n                // Upper Leaves\r\n                ctx.beginPath();\r\n                ctx.arc(px + 25, py - 10, 16, 0, Math.PI * 2);\r\n                ctx.fill();\r\n                // Highlight\r\n                ctx.fillStyle = PALETTE.leaf_light + '22'; // Subtle alpha\r\n                ctx.beginPath();\r\n                ctx.arc(px + 20, py - 15, 10, 0, Math.PI * 2);\r\n                ctx.fill();\r\n                break;\r\n\r\n            case TILES.STONE:\r\n                // Shadow\r\n                ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';\r\n                ctx.beginPath();\r\n                ctx.ellipse(px + 25, py + 40, 15, 6, 0, 0, Math.PI * 2);\r\n                ctx.fill();\r\n                // Rock Structure (3/4 depth)\r\n                ctx.fillStyle = PALETTE.stone_dark; // Front\r\n                ctx.beginPath();\r\n                ctx.moveTo(px + 10, py + 40);\r\n                ctx.lineTo(px + 10, py + 25);\r\n                ctx.lineTo(px + 20, py + 15);\r\n                ctx.lineTo(px + 40, py + 15);\r\n                ctx.lineTo(px + 45, py + 30);\r\n                ctx.lineTo(px + 45, py + 40);\r\n                ctx.closePath();\r\n                ctx.fill();\r\n                // Top Highlight\r\n                ctx.fillStyle = PALETTE.stone;\r\n                ctx.beginPath();\r\n                ctx.moveTo(px + 20, py + 15);\r\n                ctx.lineTo(px + 40, py + 15);\r\n                ctx.lineTo(px + 43, py + 25);\r\n                ctx.lineTo(px + 15, py + 25);\r\n                ctx.closePath();\r\n                ctx.fill();\r\n                break;\r\n\r\n            case TILES.STONE_ORE:\r\n                // Shadow\r\n                ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';\r\n                ctx.beginPath();\r\n                ctx.ellipse(px + 25, py + 40, 15, 6, 0, 0, Math.PI * 2);\r\n                ctx.fill();\r\n                // Rock (3/4 perspective)\r\n                ctx.fillStyle = PALETTE.stone_dark;\r\n                ctx.beginPath();\r\n                ctx.moveTo(px + 10, py + 40);\r\n                ctx.lineTo(px + 10, py + 25);\r\n                ctx.lineTo(px + 25, py + 15);\r\n                ctx.lineTo(px + 40, py + 25);\r\n                ctx.lineTo(px + 40, py + 40);\r\n                ctx.closePath();\r\n                ctx.fill();\r\n                // Ore Highlight\r\n                ctx.fillStyle = PALETTE.orange;\r\n                ctx.fillRect(px + 18, py + 22, 6, 6);\r\n                ctx.fillRect(px + 28, py + 28, 4, 4);\r\n                break;\r\n\r\n            case TILES.STONE_BOULDER:\r\n                // Shadow\r\n                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';\r\n                ctx.beginPath();\r\n                ctx.ellipse(px + 25, py + 42, 18, 8, 0, 0, Math.PI * 2);\r\n                ctx.fill();\r\n                // Large Boulder (3/4 Dome)\r\n                ctx.fillStyle = '#616161';\r\n                ctx.beginPath();\r\n                ctx.ellipse(px + 25, py + 30, 20, 15, 0, 0, Math.PI * 2);\r\n                ctx.fill();\r\n                // Upper highlight\r\n                ctx.fillStyle = '#757575';\r\n                ctx.beginPath();\r\n                ctx.ellipse(px + 22, py + 25, 12, 8, 0, 0, Math.PI * 2);\r\n                ctx.fill();\r\n                break;\r\n\r\n            case TILES.TREE_OAK:\r\n                // Shadow\r\n                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';\r\n                ctx.beginPath();\r\n                ctx.ellipse(px + 25, py + 45, 18, 8, 0, 0, Math.PI * 2);\r\n                ctx.fill();\r\n                // Trunk (Wide)\r\n                ctx.fillStyle = '#3e2723';\r\n                ctx.fillRect(px + 16, py + 10, 18, 35);\r\n                // Large Round Leaves\r\n                ctx.fillStyle = '#1b5e20';\r\n                ctx.beginPath();\r\n                ctx.arc(px + 25, py - 5, 24, 0, Math.PI * 2);\r\n                ctx.fill();\r\n                ctx.beginPath();\r\n                ctx.arc(px + 10, py + 5, 15, 0, Math.PI * 2);\r\n                ctx.fill();\r\n                ctx.beginPath();\r\n                ctx.arc(px + 40, py + 5, 15, 0, Math.PI * 2);\r\n                ctx.fill();\r\n                break;\r\n\r\n            case TILES.HOUSE:\r\n                // Draw when bottom-left is reached for correct depth sorting\r\n                if (map && this.isBottomLeftCorner(map, x, y, TILES.HOUSE)) {\r\n                    this.drawHouse3x3(px, py - (TILE_SIZE * 2), ctx);\r\n                }\r\n                break;\r\n\r\n            case TILES.SHOP:\r\n                if (map && this.isBottomLeftCorner(map, x, y, TILES.SHOP)) {\r\n                    this.drawShop3x3(px, py - (TILE_SIZE * 2), ctx);\r\n                }\r\n                break;\r\n\r\n            case TILES.OLD_HOUSE:\r\n                if (map && this.isBottomLeftCorner(map, x, y, TILES.OLD_HOUSE)) {\r\n                    this.drawOldHouse8x4(px, py - (TILE_SIZE * 3), ctx);\r\n                }\r\n                break;\r\n\r\n            case TILES.WITHERED:\r\n                // Dead crop debris - brownish soil with dead plant matter\r\n                ctx.fillStyle = '#4a3728';\r\n                ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);\r\n                // Dead roots/stems\r\n                ctx.fillStyle = '#6d5847';\r\n                ctx.fillRect(px + 8, py + 15, 4, 20);\r\n                ctx.fillRect(px + 20, py + 10, 3, 25);\r\n                ctx.fillRect(px + 35, py + 18, 4, 18);\r\n                // Wilted leaves\r\n                ctx.fillStyle = '#8b7355';\r\n                ctx.beginPath();\r\n                ctx.ellipse(px + 10, py + 12, 6, 4, 0.3, 0, Math.PI * 2);\r\n                ctx.fill();\r\n                ctx.beginPath();\r\n                ctx.ellipse(px + 22, py + 8, 5, 3, -0.2, 0, Math.PI * 2);\r\n                ctx.fill();\r\n                ctx.beginPath();\r\n                ctx.ellipse(px + 38, py + 15, 5, 3, 0.5, 0, Math.PI * 2);\r\n                ctx.fill();\r\n                break;\r\n\r\n            default:\r\n                ctx.fillStyle = colors.grass;\r\n                ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);\r\n        }\r\n\r\n        // Grid line removed to break the \"grid\" look\r\n    }\r\n\r\n    /**\r\n     * Draw a 3x3 house\r\n     */\r\n    drawHouse3x3(px, py, ctx) {\r\n        const size = TILE_SIZE * 3;\r\n        const wallTop = py + 35;\r\n        const wallBottom = py + size - 5;\r\n        const wallHeight = wallBottom - wallTop;\r\n\r\n        // Shadow\r\n        ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';\r\n        ctx.beginPath();\r\n        ctx.ellipse(px + size / 2, py + size - 2, size / 2.2, 8, 0, 0, Math.PI * 2);\r\n        ctx.fill();\r\n\r\n        // 3/4 Perspective Walls\r\n        // Side Wall (darker)\r\n        ctx.fillStyle = '#a1887f';\r\n        ctx.fillRect(px + size - 20, wallTop, 12, wallHeight);\r\n\r\n        // Front Wall\r\n        ctx.fillStyle = '#d7ccc8';\r\n        ctx.fillRect(px + 8, wallTop, size - 28, wallHeight);\r\n\r\n        // Wall Detail/Outline\r\n        ctx.strokeStyle = '#8d736b';\r\n        ctx.lineWidth = 2;\r\n        ctx.strokeRect(px + 8, wallTop, size - 28, wallHeight);\r\n\r\n        // Roof (3/4 Gabled)\r\n        ctx.fillStyle = '#4e342e'; // Main roof color\r\n        ctx.beginPath();\r\n        ctx.moveTo(px + 2, wallTop);\r\n        ctx.lineTo(px + size / 2 - 10, py + 10);\r\n        ctx.lineTo(px + size - 15, wallTop);\r\n        ctx.closePath();\r\n        ctx.fill();\r\n\r\n        // Roof Trim/Depth\r\n        ctx.fillStyle = '#5d4037';\r\n        ctx.beginPath();\r\n        ctx.moveTo(px + size / 2 - 10, py + 10);\r\n        ctx.lineTo(px + size - 5, py + 15);\r\n        ctx.lineTo(px + size - 15, wallTop);\r\n        ctx.closePath();\r\n        ctx.fill();\r\n\r\n        // Door (aligned to center tile)\r\n        const doorWidth = 24;\r\n        const doorHeight = 40;\r\n        const doorX = px + TILE_SIZE + (TILE_SIZE / 2) - (doorWidth / 2);\r\n        const doorY = wallBottom - doorHeight;\r\n\r\n        // Door Frame\r\n        ctx.fillStyle = '#3e2723';\r\n        ctx.fillRect(doorX - 2, doorY - 4, doorWidth + 4, doorHeight + 4);\r\n\r\n        // Door Body\r\n        ctx.fillStyle = '#5d4037';\r\n        ctx.fillRect(doorX, doorY, doorWidth, doorHeight);\r\n\r\n        // Door handle\r\n        ctx.fillStyle = '#ffd700';\r\n        ctx.beginPath();\r\n        ctx.arc(doorX + doorWidth - 6, doorY + doorHeight / 2, 3, 0, Math.PI * 2);\r\n        ctx.fill();\r\n\r\n        // Windows (with depth frames)\r\n        const windowSize = 22;\r\n        const winY = wallTop + 15;\r\n        this.drawFramedWindow(ctx, px + 22, winY, windowSize);\r\n        this.drawFramedWindow(ctx, px + size - 50, winY, windowSize);\r\n    }\r\n\r\n    drawFramedWindow(ctx, x, y, size) {\r\n        // Frame\r\n        ctx.fillStyle = '#5d4037';\r\n        ctx.fillRect(x - 2, y - 2, size + 4, size + 4);\r\n        // Glass\r\n        ctx.fillStyle = '#81d4fa';\r\n        ctx.fillRect(x, y, size, size);\r\n        // Reflection\r\n        ctx.fillStyle = 'rgba(255,255,255,0.3)';\r\n        ctx.beginPath();\r\n        ctx.moveTo(x, y);\r\n        ctx.lineTo(x + size, y);\r\n        ctx.lineTo(x, y + size);\r\n        ctx.closePath();\r\n        ctx.fill();\r\n        // Crossbars\r\n        ctx.strokeStyle = '#5d4037';\r\n        ctx.lineWidth = 1;\r\n        ctx.beginPath();\r\n        ctx.moveTo(x + size / 2, y);\r\n        ctx.lineTo(x + size / 2, y + size);\r\n        ctx.moveTo(x, y + size / 2);\r\n        ctx.lineTo(x + size, y + size / 2);\r\n        ctx.stroke();\r\n    }\r\n\r\n    /**\r\n     * Draw a 3x3 shop\r\n     */\r\n    drawShop3x3(px, py, ctx) {\r\n        const size = TILE_SIZE * 3;\r\n        const buildingTop = py + 25;\r\n        const buildingBottom = py + size - 5;\r\n        const buildingHeight = buildingBottom - buildingTop;\r\n\r\n        // Shadow\r\n        ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';\r\n        ctx.beginPath();\r\n        ctx.ellipse(px + size / 2, py + size - 2, size / 2.2, 8, 0, 0, Math.PI * 2);\r\n        ctx.fill();\r\n\r\n        // 3/4 Perspective Walls\r\n        // Side Wall (darker)\r\n        ctx.fillStyle = '#37474f';\r\n        ctx.fillRect(px + size - 20, buildingTop, 12, buildingHeight);\r\n\r\n        // Building body\r\n        ctx.fillStyle = '#546e7a';\r\n        ctx.fillRect(px + 8, buildingTop, size - 28, buildingHeight);\r\n\r\n        // Building outline\r\n        ctx.strokeStyle = '#263238';\r\n        ctx.lineWidth = 2;\r\n        ctx.strokeRect(px + 8, buildingTop, size - 28, buildingHeight);\r\n\r\n        // Flat Roof with depth\r\n        ctx.fillStyle = '#263238';\r\n        ctx.fillRect(px + 4, buildingTop - 5, size - 20, 10);\r\n\r\n        // Awning (slanted for perspective)\r\n        const awningTop = buildingTop + 5;\r\n        const awningHeight = 25;\r\n        ctx.fillStyle = '#e53935';\r\n        ctx.fillRect(px + 4, awningTop, size - 12, awningHeight);\r\n\r\n        // Awning stripes\r\n        ctx.fillStyle = 'white';\r\n        const stripeWidth = (size - 12) / 8;\r\n        for (let i = 0; i < 4; i++) {\r\n            ctx.fillRect(px + 4 + (i * 2 * stripeWidth), awningTop, stripeWidth, awningHeight);\r\n        }\r\n\r\n        // Sign (3D effect)\r\n        const signTop = py + 5;\r\n        ctx.fillStyle = '#4e342e'; // Wood post\r\n        ctx.fillRect(px + size / 2 - 2, signTop + 10, 4, 15);\r\n\r\n        ctx.fillStyle = '#ffeb3b';\r\n        ctx.fillRect(px + size / 2 - 35, signTop, 70, 24);\r\n        ctx.strokeStyle = '#f9a825';\r\n        ctx.lineWidth = 2;\r\n        ctx.strokeRect(px + size / 2 - 35, signTop, 70, 24);\r\n\r\n        ctx.fillStyle = '#000';\r\n        ctx.font = 'bold 14px Arial';\r\n        ctx.textAlign = 'center';\r\n        ctx.textBaseline = 'middle';\r\n        ctx.fillText('SHOP', px + size / 2, signTop + 13);\r\n        ctx.textAlign = 'left';\r\n        ctx.textBaseline = 'alphabetic';\r\n\r\n        // Door (centered)\r\n        const doorWidth = 24;\r\n        const doorHeight = 40;\r\n        const doorX = px + TILE_SIZE + (TILE_SIZE / 2) - (doorWidth / 2);\r\n        const doorY = buildingBottom - doorHeight;\r\n\r\n        ctx.fillStyle = '#1b1b1b';\r\n        ctx.fillRect(doorX, doorY, doorWidth, doorHeight);\r\n        ctx.strokeStyle = '#37474f';\r\n        ctx.lineWidth = 2;\r\n        ctx.strokeRect(doorX, doorY, doorWidth, doorHeight);\r\n\r\n        // Display windows\r\n        const windowWidth = 26;\r\n        const windowHeight = 24;\r\n        const windowY = awningTop + awningHeight + 5;\r\n\r\n        ctx.fillStyle = '#000'; // Window interior\r\n        ctx.fillRect(px + 15, windowY, windowWidth, windowHeight);\r\n        ctx.fillRect(px + size - 15 - windowWidth - 12, windowY, windowWidth, windowHeight);\r\n\r\n        // Window frames\r\n        ctx.strokeStyle = '#cfd8dc';\r\n        ctx.lineWidth = 2;\r\n        ctx.strokeRect(px + 15, windowY, windowWidth, windowHeight);\r\n        ctx.strokeRect(px + size - 15 - windowWidth - 12, windowY, windowWidth, windowHeight);\r\n\r\n        // Window items\r\n        ctx.fillStyle = '#ff9800';\r\n        ctx.fillRect(px + 18, windowY + 8, 8, 10);\r\n        ctx.fillStyle = '#4caf50';\r\n        ctx.fillRect(px + size - 25 - 12, windowY + 8, 8, 10);\r\n    }\r\n\r\n    /**\r\n     * Draw Old House (8x4)\r\n     */\r\n    drawOldHouse8x4(px, py, ctx) {\r\n        const width = TILE_SIZE * 8;\r\n        const height = TILE_SIZE * 4;\r\n\r\n        // Shadow\r\n        ctx.fillStyle = 'rgba(0,0,0,0.3)';\r\n        ctx.beginPath();\r\n        ctx.ellipse(px + width / 2, py + height - 5, width / 2 - 10, 10, 0, 0, Math.PI * 2);\r\n        ctx.fill();\r\n\r\n        // 3/4 Perspective Walls\r\n        // Side Wall (darker)\r\n        ctx.fillStyle = PALETTE.wood_dark;\r\n        ctx.fillRect(px + width - 40, py + 40, 20, height - 50);\r\n\r\n        // Front Wall\r\n        ctx.fillStyle = PALETTE.wood;\r\n        ctx.fillRect(px + 20, py + 40, width - 60, height - 50);\r\n\r\n        // Wall Detail/Outline\r\n        ctx.strokeStyle = '#2d1b18';\r\n        ctx.lineWidth = 2;\r\n        ctx.strokeRect(px + 20, py + 40, width - 60, height - 50);\r\n\r\n        // Roof (Weathered shingles with depth)\r\n        ctx.fillStyle = '#263238'; // Darker roof\r\n        ctx.beginPath();\r\n        ctx.moveTo(px + 5, py + 40);\r\n        ctx.lineTo(px + width / 2, py + 5);\r\n        ctx.lineTo(px + width - 15, py + 40);\r\n        ctx.closePath();\r\n        ctx.fill();\r\n\r\n        // Roof Trim\r\n        ctx.strokeStyle = '#37474f';\r\n        ctx.lineWidth = 3;\r\n        ctx.strokeRect(px + 5, py + 40, width - 20, 2);\r\n\r\n        // Door (Aligned to tiles 3 and 4)\r\n        // Door is 2 tiles wide (100px), centered roughly\r\n        const doorW = TILE_SIZE * 2;\r\n        const doorH = 65;\r\n        const doorX = px + TILE_SIZE * 3; // Exactly aligned to column 4 (if 0-indexed) or similar\r\n        const doorY = py + height - 10 - doorH;\r\n\r\n        // Door Frame\r\n        ctx.fillStyle = '#1b1b1b';\r\n        ctx.fillRect(doorX - 4, doorY - 4, doorW + 8, doorH + 4);\r\n\r\n        // Door Body\r\n        ctx.fillStyle = '#212121';\r\n        ctx.fillRect(doorX, doorY, doorW, doorH);\r\n\r\n        // Door Detail (Boarded)\r\n        ctx.fillStyle = '#3e2723';\r\n        ctx.fillRect(doorX + 10, doorY + 20, doorW - 20, 8);\r\n        ctx.fillRect(doorX + 10, doorY + 40, doorW - 20, 8);\r\n\r\n        // Windows (Boarded up)\r\n        this.drawBoardedWindow(ctx, px + 50, py + 70);\r\n        this.drawBoardedWindow(ctx, px + width - 120, py + 70);\r\n    }\r\n\r\n    drawBoardedWindow(ctx, x, y) {\r\n        ctx.fillStyle = '#000';\r\n        ctx.fillRect(x, y, 40, 40);\r\n        ctx.fillStyle = '#8d6e63';\r\n        // Boards\r\n        ctx.save();\r\n        ctx.translate(x + 20, y + 20);\r\n        ctx.rotate(0.1);\r\n        ctx.fillRect(-22, -5, 44, 10);\r\n        ctx.rotate(-0.2);\r\n        ctx.fillRect(-22, -5, 44, 10);\r\n        ctx.restore();\r\n    }\r\n\r\n    /**\r\n     * Draw NPC\r\n     */\r\n    drawNPC(ctx, x, y, id) {\r\n        // Center NPC in tile\r\n        const drawX = x + TILE_SIZE / 2;\r\n        const drawY = y + TILE_SIZE / 2;\r\n\r\n        if (id === 'old_man') {\r\n            // Use standard player-like proportions for Old Man\r\n            const px = drawX - 10;\r\n            const py = drawY - 15;\r\n\r\n            // Robe/Body\r\n            ctx.fillStyle = '#6d4c41';\r\n            ctx.fillRect(px + 2, py + 8, 16, 22);\r\n\r\n            // Head\r\n            ctx.fillStyle = '#ffcc80';\r\n            ctx.fillRect(px + 2, py - 6, 16, 14);\r\n\r\n            // Beard (White, 3/4 depth)\r\n            ctx.fillStyle = '#eeeeee';\r\n            ctx.fillRect(px + 2, py + 4, 16, 8);\r\n            ctx.fillRect(px + 4, py + 12, 12, 6);\r\n\r\n            // Staff\r\n            ctx.fillStyle = '#8d6e63';\r\n            ctx.fillRect(px + 20, py - 5, 4, 38);\r\n\r\n            // Eyes\r\n            ctx.fillStyle = 'black';\r\n            ctx.fillRect(px + 5, py - 2, 2, 2);\r\n            ctx.fillRect(px + 13, py - 2, 2, 2);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Draw a crop\r\n     */\r\n    drawCrop(crop, x, y) {\r\n        const ctx = this.ctx;\r\n        const px = x * TILE_SIZE;\r\n        const py = y * TILE_SIZE;\r\n        const growth = crop.stage / 100;\r\n        const data = SEEDS[crop.type];\r\n\r\n        if (data.isTree) {\r\n            // Shadow\r\n            ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';\r\n            ctx.beginPath();\r\n            ctx.ellipse(px + 25, py + 45, 12, 5, 0, 0, Math.PI * 2);\r\n            ctx.fill();\r\n\r\n            if (growth < 0.5) {\r\n                // Sapling (3/4)\r\n                ctx.fillStyle = '#5d4037';\r\n                ctx.fillRect(px + 23, py + 25, 4, 20);\r\n                ctx.fillStyle = '#43a047';\r\n                ctx.beginPath();\r\n                ctx.arc(px + 25, py + 20, 10, 0, Math.PI * 2);\r\n                ctx.fill();\r\n            } else {\r\n                // Fruit tree (Match Overworld style)\r\n                ctx.fillStyle = '#5d4037';\r\n                ctx.fillRect(px + 21, py + 15, 8, 30);\r\n                // Lower Leaves\r\n                ctx.fillStyle = '#2e7d32';\r\n                ctx.beginPath();\r\n                ctx.arc(px + 25, py + 5, 20, 0, Math.PI * 2);\r\n                ctx.fill();\r\n                // Upper Leaves\r\n                ctx.beginPath();\r\n                ctx.arc(px + 25, py - 10, 16, 0, Math.PI * 2);\r\n                ctx.fill();\r\n\r\n                // Fruit\r\n                if (growth >= 1) {\r\n                    ctx.fillStyle = data.color || '#e53935';\r\n                    ctx.beginPath();\r\n                    ctx.arc(px + 15, py + 5, 5, 0, Math.PI * 2);\r\n                    ctx.fill();\r\n                    ctx.beginPath();\r\n                    ctx.arc(px + 35, py, 5, 0, Math.PI * 2);\r\n                    ctx.fill();\r\n                    ctx.beginPath();\r\n                    ctx.arc(px + 25, py + 12, 5, 0, Math.PI * 2);\r\n                    ctx.fill();\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            // Regular crop\r\n            ctx.fillStyle = '#8bc34a';\r\n\r\n            if (growth < 0.5) {\r\n                // Seedling\r\n                ctx.fillRect(px + 22, py + 25, 6, 8);\r\n            } else {\r\n                // Growing plant\r\n                const h = 10 + (15 * growth);\r\n                ctx.fillStyle = '#689f38';\r\n                ctx.fillRect(px + 22, py + 40 - h, 6, h);\r\n\r\n                // Harvestable produce\r\n                if (growth >= 1) {\r\n                    ctx.fillStyle = data.color;\r\n                    ctx.beginPath();\r\n                    ctx.arc(px + 25, py + 40 - h, 7, 0, Math.PI * 2);\r\n                    ctx.fill();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Draw an interior tile\r\n     */\r\n    drawInteriorTile(tileType, x, y) {\r\n        const ctx = this.ctx;\r\n        const px = x * TILE_SIZE;\r\n        const py = y * TILE_SIZE;\r\n\r\n        switch (tileType) {\r\n            case INTERIOR_TILES.FLOOR:\r\n                // Wooden floor\r\n                ctx.fillStyle = PALETTE.wood;\r\n                ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);\r\n                // Floor boards\r\n                ctx.strokeStyle = PALETTE.wood_dark;\r\n                ctx.lineWidth = 1;\r\n                ctx.beginPath();\r\n                ctx.moveTo(px, py + 10);\r\n                ctx.lineTo(px + TILE_SIZE, py + 10);\r\n                ctx.moveTo(px, py + 25);\r\n                ctx.lineTo(px + TILE_SIZE, py + 25);\r\n                ctx.moveTo(px, py + 40);\r\n                ctx.lineTo(px + TILE_SIZE, py + 40);\r\n                ctx.stroke();\r\n                break;\r\n\r\n            case INTERIOR_TILES.WALL:\r\n                // Stone/plaster wall\r\n                ctx.fillStyle = PALETTE.white;\r\n                ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);\r\n                // Wall texture hints\r\n                ctx.fillStyle = PALETTE.stone;\r\n                ctx.fillRect(px + 2, py + 5, 10, 4);\r\n                ctx.fillRect(px + 30, py + 15, 8, 4);\r\n                break;\r\n\r\n            case INTERIOR_TILES.DOOR:\r\n                // Floor first\r\n                ctx.fillStyle = '#deb887';\r\n                ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);\r\n                // Door mat\r\n                ctx.fillStyle = '#8d6e63';\r\n                ctx.fillRect(px + 5, py + 5, TILE_SIZE - 10, TILE_SIZE - 10);\r\n                // Welcome text\r\n                ctx.fillStyle = '#5d4037';\r\n                ctx.font = '8px Arial';\r\n                ctx.textAlign = 'center';\r\n                ctx.fillText('EXIT', px + TILE_SIZE / 2, py + TILE_SIZE / 2 + 3);\r\n                ctx.textAlign = 'left';\r\n                break;\r\n\r\n            case INTERIOR_TILES.BED:\r\n                // Floor\r\n                ctx.fillStyle = PALETTE.wood;\r\n                ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);\r\n                // Shadow\r\n                ctx.fillStyle = 'rgba(0,0,0,0.1)';\r\n                ctx.fillRect(px + 4, py + 6, TILE_SIZE - 4, TILE_SIZE - 4);\r\n                // Bed frame (3/4)\r\n                ctx.fillStyle = PALETTE.wood_dark;\r\n                ctx.fillRect(px + 2, py + 2, TILE_SIZE - 6, TILE_SIZE - 4);\r\n                // Mattress\r\n                ctx.fillStyle = PALETTE.white;\r\n                ctx.fillRect(px + 5, py + 8, TILE_SIZE - 12, TILE_SIZE - 15);\r\n                // Headboard\r\n                ctx.fillStyle = PALETTE.wood;\r\n                ctx.fillRect(px + 2, py + 2, TILE_SIZE - 6, 8);\r\n                // Pillow\r\n                ctx.fillStyle = PALETTE.white;\r\n                ctx.fillRect(px + 10, py + 10, TILE_SIZE - 20, 8);\r\n                // Blanket\r\n                ctx.fillStyle = PALETTE.water_dark;\r\n                ctx.fillRect(px + 5, py + 22, TILE_SIZE - 12, 20);\r\n                break;\r\n\r\n            case INTERIOR_TILES.TABLE:\r\n                // Floor\r\n                ctx.fillStyle = '#deb887';\r\n                ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);\r\n                // Shadow\r\n                ctx.fillStyle = 'rgba(0,0,0,0.1)';\r\n                ctx.fillRect(px + 8, py + 25, TILE_SIZE - 16, 20);\r\n                // Table Legs (Front)\r\n                ctx.fillStyle = '#5d4037';\r\n                ctx.fillRect(px + 8, py + 25, 4, 15);\r\n                ctx.fillRect(px + TILE_SIZE - 12, py + 25, 4, 15);\r\n                // Table top\r\n                ctx.fillStyle = '#795548';\r\n                ctx.fillRect(px + 5, py + 10, TILE_SIZE - 10, 15);\r\n                // Top Detail\r\n                ctx.strokeStyle = '#5d4037';\r\n                ctx.lineWidth = 1;\r\n                ctx.strokeRect(px + 5, py + 10, TILE_SIZE - 10, 15);\r\n                break;\r\n\r\n            case INTERIOR_TILES.RUG:\r\n                // Floor\r\n                ctx.fillStyle = PALETTE.wood;\r\n                ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);\r\n                // Rug (More decorative, less like a chair)\r\n                ctx.fillStyle = PALETTE.red;\r\n                ctx.fillRect(px + 2, py + 2, TILE_SIZE - 4, TILE_SIZE - 4);\r\n                // Pattern\r\n                ctx.strokeStyle = PALETTE.highlight;\r\n                ctx.lineWidth = 2;\r\n                ctx.strokeRect(px + 8, py + 8, TILE_SIZE - 16, TILE_SIZE - 16);\r\n                break;\r\n\r\n            case INTERIOR_TILES.CHAIR:\r\n                // Floor\r\n                ctx.fillStyle = PALETTE.wood;\r\n                ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);\r\n                // Chair Shadow\r\n                ctx.fillStyle = 'rgba(0,0,0,0.2)';\r\n                ctx.fillRect(px + 10, py + 10, TILE_SIZE - 20, TILE_SIZE - 20);\r\n                // Chair Legs\r\n                ctx.fillStyle = PALETTE.wood_dark;\r\n                ctx.fillRect(px + 12, py + 12, 4, 4);\r\n                ctx.fillRect(px + TILE_SIZE - 16, py + 12, 4, 4);\r\n                ctx.fillRect(px + 12, py + TILE_SIZE - 16, 4, 4);\r\n                ctx.fillRect(px + TILE_SIZE - 16, py + TILE_SIZE - 16, 4, 4);\r\n                // Chair Seat\r\n                ctx.fillStyle = PALETTE.wood;\r\n                ctx.fillRect(px + 10, py + 10, TILE_SIZE - 20, TILE_SIZE - 20);\r\n                // Chair Back\r\n                ctx.fillStyle = PALETTE.wood_dark;\r\n                ctx.fillRect(px + 10, py + 10, TILE_SIZE - 20, 6);\r\n                break;\r\n\r\n            case INTERIOR_TILES.STOVE:\r\n                // Floor\r\n                ctx.fillStyle = PALETTE.wood;\r\n                ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);\r\n                // Stove body\r\n                ctx.fillStyle = PALETTE.black;\r\n                ctx.fillRect(px + 5, py + 10, TILE_SIZE - 10, TILE_SIZE - 15);\r\n                // Stove top\r\n                ctx.fillStyle = PALETTE.stone_dark;\r\n                ctx.fillRect(px + 5, py + 5, TILE_SIZE - 10, 10);\r\n                // Burners\r\n                ctx.fillStyle = PALETTE.red;\r\n                ctx.beginPath();\r\n                ctx.arc(px + 18, py + 10, 5, 0, Math.PI * 2);\r\n                ctx.arc(px + 32, py + 10, 5, 0, Math.PI * 2);\r\n                ctx.fill();\r\n                break;\r\n\r\n            case INTERIOR_TILES.CHEST:\r\n                // Floor\r\n                ctx.fillStyle = PALETTE.wood;\r\n                ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);\r\n                // Chest body\r\n                ctx.fillStyle = PALETTE.wood;\r\n                ctx.fillRect(px + 5, py + 15, TILE_SIZE - 10, TILE_SIZE - 20);\r\n                // Chest lid\r\n                ctx.fillStyle = PALETTE.wood_dark;\r\n                ctx.fillRect(px + 5, py + 10, TILE_SIZE - 10, 10);\r\n                // Lock\r\n                ctx.fillStyle = PALETTE.highlight;\r\n                ctx.fillRect(px + 20, py + 18, 8, 8);\r\n                break;\r\n\r\n            case INTERIOR_TILES.COUNTER:\r\n                // Floor\r\n                ctx.fillStyle = PALETTE.wood;\r\n                ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);\r\n                // Counter Top\r\n                ctx.fillStyle = PALETTE.stone;\r\n                ctx.fillRect(px, py + 5, TILE_SIZE, TILE_SIZE - 5);\r\n                // Counter Front Detail\r\n                ctx.fillStyle = PALETTE.wood;\r\n                ctx.fillRect(px, py + 15, TILE_SIZE, TILE_SIZE - 15);\r\n                // Border\r\n                ctx.strokeStyle = PALETTE.wood_dark;\r\n                ctx.lineWidth = 1;\r\n                ctx.strokeRect(px, py + 5, TILE_SIZE, TILE_SIZE - 5);\r\n                break;\r\n\r\n            case INTERIOR_TILES.SHELF:\r\n                // Floor\r\n                ctx.fillStyle = '#deb887';\r\n                ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);\r\n                // Shelf backing\r\n                ctx.fillStyle = '#5d4037';\r\n                ctx.fillRect(px + 2, py + 2, TILE_SIZE - 4, TILE_SIZE - 4);\r\n                // Shelves\r\n                ctx.fillStyle = '#8d6e63';\r\n                ctx.fillRect(px + 4, py + 15, TILE_SIZE - 8, 4);\r\n                ctx.fillRect(px + 4, py + 30, TILE_SIZE - 8, 4);\r\n                // Items\r\n                ctx.fillStyle = '#ef5350';\r\n                ctx.fillRect(px + 8, py + 8, 6, 6);\r\n                ctx.fillStyle = '#42a5f5';\r\n                ctx.fillRect(px + 20, py + 8, 5, 7);\r\n                ctx.fillStyle = '#ffca28';\r\n                ctx.fillRect(px + 10, py + 22, 8, 6);\r\n                break;\r\n\r\n            case INTERIOR_TILES.TV:\r\n                // Floor\r\n                ctx.fillStyle = PALETTE.wood;\r\n                ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);\r\n                // TV Shadow\r\n                ctx.fillStyle = 'rgba(0,0,0,0.2)';\r\n                ctx.fillRect(px + 6, py + 35, TILE_SIZE - 12, 10);\r\n                // CRT Box (3/4 depth)\r\n                ctx.fillStyle = PALETTE.black;\r\n                ctx.fillRect(px + 5, py + 5, TILE_SIZE - 10, 30);\r\n                // Screen\r\n                ctx.fillStyle = PALETTE.water_dark;\r\n                ctx.fillRect(px + 10, py + 8, TILE_SIZE - 25, 20);\r\n                // Stand\r\n                ctx.fillStyle = PALETTE.stone;\r\n                ctx.fillRect(px + 15, py + 35, TILE_SIZE - 30, 5);\r\n                break;\r\n\r\n            case INTERIOR_TILES.COUCH:\r\n                // Floor\r\n                ctx.fillStyle = PALETTE.wood;\r\n                ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);\r\n                // Shadow\r\n                ctx.fillStyle = 'rgba(0,0,0,0.1)';\r\n                ctx.fillRect(px + 4, py + 35, TILE_SIZE - 8, 10);\r\n                // Backboard (3/4 perspective high)\r\n                ctx.fillStyle = PALETTE.stone_dark;\r\n                ctx.fillRect(px + 2, py, TILE_SIZE - 4, 30);\r\n                // Cushions\r\n                ctx.fillStyle = PALETTE.stone;\r\n                ctx.fillRect(px + 2, py + 15, TILE_SIZE - 4, 25);\r\n                break;\r\n                ctx.fillRect(px + 8, py + 20, TILE_SIZE - 16, 25);\r\n                break;\r\n\r\n            case INTERIOR_TILES.PLANT:\r\n                // Floor\r\n                ctx.fillStyle = '#deb887';\r\n                ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);\r\n                // Pot\r\n                ctx.fillStyle = '#d84315';\r\n                ctx.beginPath();\r\n                ctx.moveTo(px + 15, py + 45);\r\n                ctx.lineTo(px + 35, py + 45);\r\n                ctx.lineTo(px + 40, py + 30);\r\n                ctx.lineTo(px + 10, py + 30);\r\n                ctx.fill();\r\n                // Leaves\r\n                ctx.fillStyle = '#43a047';\r\n                ctx.beginPath();\r\n                ctx.arc(px + 25, py + 25, 12, 0, Math.PI * 2);\r\n                ctx.fill();\r\n                break;\r\n\r\n            default:\r\n                // Default floor\r\n                ctx.fillStyle = '#deb887';\r\n                ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);\r\n        }\r\n\r\n        // Grid line removed to break the \"grid\" look\r\n    }\r\n\r\n    /**\r\n     * Draw autotiled soil\r\n     */\r\n    drawAutotiledSoil(ctx, px, py, x, y, map) {\r\n        // bitmask: 1=N, 2=E, 4=S, 8=W\r\n        let mask = 0;\r\n        if (y > 0 && map[y - 1] && map[y - 1][x] === TILES.SOIL) mask |= 1;\r\n        if (x < map[0].length - 1 && map[y][x + 1] === TILES.SOIL) mask |= 2;\r\n        if (y < map.length - 1 && map[y + 1] && map[y + 1][x] === TILES.SOIL) mask |= 4;\r\n        if (x > 0 && map[y][x - 1] === TILES.SOIL) mask |= 8;\r\n\r\n        const inset = 4;\r\n        const radius = 12;\r\n\r\n        // Base Dirt\r\n        ctx.fillStyle = PALETTE.soil;\r\n\r\n        const tlR = (mask & 9) === 9 ? 0 : radius;\r\n        const trR = (mask & 3) === 3 ? 0 : radius;\r\n        const brR = (mask & 6) === 6 ? 0 : radius;\r\n        const blR = (mask & 12) === 12 ? 0 : radius;\r\n\r\n        const x1 = (mask & 8) ? px : px + inset;\r\n        const y1 = (mask & 1) ? py : py + inset;\r\n        const x2 = (mask & 2) ? px + TILE_SIZE : px + TILE_SIZE - inset;\r\n        const y2 = (mask & 4) ? py + TILE_SIZE : py + TILE_SIZE - inset;\r\n        const w = x2 - x1;\r\n        const h = y2 - y1;\r\n\r\n        ctx.beginPath();\r\n        if (ctx.roundRect) {\r\n            ctx.roundRect(x1, y1, w, h, [tlR, trR, brR, blR]);\r\n        } else {\r\n            ctx.rect(x1, y1, w, h);\r\n        }\r\n        ctx.fill();\r\n\r\n        // Dirt Texture\r\n        ctx.fillStyle = 'rgba(0,0,0,0.1)';\r\n        for (let i = 1; i < 4; i++) {\r\n            const ty = y1 + (h / 4) * i;\r\n            ctx.fillRect(x1 + 2, ty, w - 4, 1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Draw procedural grass decoration\r\n     */\r\n    drawGrassDecoration(ctx, px, py, x, y) {\r\n        const seed = (x * 73856093) ^ (y * 19349663);\r\n        const rand = (Math.abs(seed) % 100) / 100;\r\n\r\n        if (rand < 0.15) {\r\n            ctx.fillStyle = 'rgba(0,0,0,0.1)';\r\n            const ox = 10 + rand * 20;\r\n            const oy = 10 + (1 - rand) * 20;\r\n            ctx.fillRect(px + ox, py + oy, 2, 4);\r\n            ctx.fillRect(px + ox + 4, py + oy - 2, 2, 6);\r\n        } else if (rand < 0.18) {\r\n            const fx = px + 15 + rand * 15;\r\n            const fy = py + 15 + (1 - rand) * 15;\r\n            ctx.fillStyle = 'white';\r\n            ctx.beginPath();\r\n            ctx.arc(fx, fy, 2, 0, Math.PI * 2);\r\n            ctx.fill();\r\n            ctx.fillStyle = '#ffd54f';\r\n            ctx.beginPath();\r\n            ctx.arc(fx, fy, 0.8, 0, Math.PI * 2);\r\n            ctx.fill();\r\n        }\r\n    }\r\n}\r\n\r\nexport default TileRenderer;\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\njyti\\Desktop\\Google-Antigravity\\2d-farming-game\\src\\systems\\Buildings.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'TILE_SIZE' is defined but never used.","line":6,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":6,"endColumn":19,"suggestions":[{"messageId":"removeVar","data":{"varName":"TILE_SIZE"},"fix":{"range":[112,122],"text":""},"desc":"Remove unused variable 'TILE_SIZE'."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Building System\r\n * Handles multi-tile building placement, persistence, and management\r\n */\r\n\r\nimport { TILE_SIZE, TILES } from '../game/constants.js';\r\nimport { isSolid, setTile } from './MapGenerator.js';\r\n\r\n// Building type definitions\r\nexport const BUILDING_TYPES = {\r\n    BARN: {\r\n        name: 'Barn',\r\n        size: [4, 4],\r\n        cost: { wood: 100, stone: 50 },\r\n        capacity: 4,        // Max animals\r\n        animalTypes: ['cow'],\r\n        tileId: 20,\r\n        color: '#8d6e63'\r\n    },\r\n    COOP: {\r\n        name: 'Coop',\r\n        size: [3, 3],\r\n        cost: { wood: 50, stone: 25 },\r\n        capacity: 8,\r\n        animalTypes: ['chicken'],\r\n        tileId: 21,\r\n        color: '#ffcc80'\r\n    },\r\n    SILO: {\r\n        name: 'Silo',\r\n        size: [2, 3],\r\n        cost: { wood: 30, stone: 80 },\r\n        capacity: 0,        // Storage, not animals\r\n        storage: 500,       // Hay/feed storage\r\n        tileId: 22,\r\n        color: '#78909c'\r\n    }\r\n};\r\n\r\n/**\r\n * Check if a building can be placed at coordinates\r\n * @param {number[][]} map - The game map\r\n * @param {number} x - Top-left X coordinate\r\n * @param {number} y - Top-left Y coordinate\r\n * @param {number[]} size - [width, height] of building\r\n * @param {object} crops - Crops object\r\n * @param {object} SEEDS - Seeds data\r\n * @returns {boolean} Whether placement is valid\r\n */\r\nexport function canPlaceBuilding(map, x, y, size, crops = {}, SEEDS = {}) {\r\n    const [width, height] = size;\r\n\r\n    // Check all tiles in the building footprint\r\n    for (let dy = 0; dy < height; dy++) {\r\n        for (let dx = 0; dx < width; dx++) {\r\n            const tx = x + dx;\r\n            const ty = y + dy;\r\n\r\n            // Check bounds and if tile is clear\r\n            if (isSolid(map, tx, ty, crops, SEEDS)) {\r\n                return false;\r\n            }\r\n\r\n            // Also check that it's grass (can't build on soil)\r\n            if (map[ty]?.[tx] !== TILES.GRASS) {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\n/**\r\n * Place a building on the map\r\n * @param {object} state - Game state\r\n * @param {string} buildingType - Type key from BUILDING_TYPES\r\n * @param {number} x - Top-left X coordinate\r\n * @param {number} y - Top-left Y coordinate\r\n * @returns {object|null} Building object if placed, null if failed\r\n */\r\nexport function placeBuilding(state, buildingType, x, y) {\r\n    const buildingDef = BUILDING_TYPES[buildingType];\r\n    if (!buildingDef) return null;\r\n\r\n    const [width, height] = buildingDef.size;\r\n\r\n    // Mark tiles as building\r\n    for (let dy = 0; dy < height; dy++) {\r\n        for (let dx = 0; dx < width; dx++) {\r\n            setTile(state.map, x + dx, y + dy, buildingDef.tileId);\r\n        }\r\n    }\r\n\r\n    // Create building record\r\n    const building = {\r\n        id: Date.now(),\r\n        type: buildingType,\r\n        x,\r\n        y,\r\n        width,\r\n        height,\r\n        animals: [],\r\n        storage: buildingDef.storage || 0,\r\n        currentStorage: 0\r\n    };\r\n\r\n    // Add to state\r\n    if (!state.buildings) {\r\n        state.buildings = [];\r\n    }\r\n    state.buildings.push(building);\r\n\r\n    return building;\r\n}\r\n\r\n/**\r\n * Remove a building from the map\r\n */\r\nexport function removeBuilding(state, buildingId) {\r\n    const idx = state.buildings?.findIndex(b => b.id === buildingId);\r\n    if (idx === -1) return false;\r\n\r\n    const building = state.buildings[idx];\r\n\r\n    // Clear tiles\r\n    for (let dy = 0; dy < building.height; dy++) {\r\n        for (let dx = 0; dx < building.width; dx++) {\r\n            setTile(state.map, building.x + dx, building.y + dy, TILES.GRASS);\r\n        }\r\n    }\r\n\r\n    // Remove from state\r\n    state.buildings.splice(idx, 1);\r\n    return true;\r\n}\r\n\r\n/**\r\n * Get building at coordinates\r\n */\r\nexport function getBuildingAt(state, x, y) {\r\n    return state.buildings?.find(b =>\r\n        x >= b.x && x < b.x + b.width &&\r\n        y >= b.y && y < b.y + b.height\r\n    );\r\n}\r\n\r\n/**\r\n * Check if player can afford building\r\n */\r\nexport function canAffordBuilding(inventory, buildingType) {\r\n    const buildingDef = BUILDING_TYPES[buildingType];\r\n    if (!buildingDef) return false;\r\n\r\n    for (const [resource, amount] of Object.entries(buildingDef.cost)) {\r\n        const slot = inventory.slots.find(s => s?.name === resource);\r\n        if (!slot || slot.count < amount) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n\r\n/**\r\n * Deduct building cost from inventory\r\n */\r\nexport function deductBuildingCost(inventory, buildingType) {\r\n    const buildingDef = BUILDING_TYPES[buildingType];\r\n    if (!buildingDef) return false;\r\n\r\n    for (const [resource, amount] of Object.entries(buildingDef.cost)) {\r\n        const slotIdx = inventory.slots.findIndex(s => s?.name === resource);\r\n        if (slotIdx !== -1) {\r\n            inventory.removeFromSlot(slotIdx, amount);\r\n        }\r\n    }\r\n    return true;\r\n}\r\n\r\nexport default {\r\n    BUILDING_TYPES,\r\n    canPlaceBuilding,\r\n    placeBuilding,\r\n    removeBuilding,\r\n    getBuildingAt,\r\n    canAffordBuilding,\r\n    deductBuildingCost\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\njyti\\Desktop\\Google-Antigravity\\2d-farming-game\\src\\systems\\InteriorMaps.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\njyti\\Desktop\\Google-Antigravity\\2d-farming-game\\src\\systems\\Inventory.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\njyti\\Desktop\\Google-Antigravity\\2d-farming-game\\src\\systems\\MapGenerator.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'NPC_IDS' is defined but never used.","line":7,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":7,"endColumn":17,"suggestions":[{"messageId":"removeVar","data":{"varName":"NPC_IDS"},"fix":{"range":[166,213],"text":""},"desc":"Remove unused variable 'NPC_IDS'."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Map Generator\r\n * Procedural map generation with buildings and terrain\r\n */\r\n\r\nimport { MAP_WIDTH, MAP_HEIGHT, TILES, MAP_GEN } from '../game/constants.js';\r\nimport { NPC_IDS } from '../game/constants.js';\r\n\r\n/**\r\n * Generate a new game map\r\n * @returns {number[][]} 2D array of tile types\r\n */\r\nexport function generateMap() {\r\n    const map = [];\r\n\r\n    // Generate base terrain\r\n    for (let y = 0; y < MAP_HEIGHT; y++) {\r\n        const row = [];\r\n        for (let x = 0; x < MAP_WIDTH; x++) {\r\n            const rand = Math.random();\r\n\r\n            if (rand < MAP_GEN.TREE_CHANCE) {\r\n                // 30% chance for Oak\r\n                row.push(Math.random() < 0.3 ? TILES.TREE_OAK : TILES.TREE);\r\n            } else if (rand < MAP_GEN.STONE_CHANCE) {\r\n                // 20% chance for Ore, 10% for Boulder\r\n                const stoneRand = Math.random();\r\n                if (stoneRand < 0.2) row.push(TILES.STONE_ORE);\r\n                else if (stoneRand < 0.3) row.push(TILES.STONE_BOULDER);\r\n                else row.push(TILES.STONE);\r\n            } else {\r\n                row.push(TILES.GRASS);\r\n            }\r\n        }\r\n        map.push(row);\r\n    }\r\n\r\n    // Place buildings at center - 2x2 buildings\r\n    const cx = Math.floor(MAP_WIDTH / 2);\r\n    const cy = Math.floor(MAP_HEIGHT / 2);\r\n\r\n    // House is 3x3 (top-left at cx-5, cy-4)\r\n    for (let y = cy - 4; y < cy - 1; y++) {\r\n        for (let x = cx - 5; x < cx - 2; x++) {\r\n            map[y][x] = TILES.HOUSE;\r\n        }\r\n    }\r\n\r\n    // Shop is 3x3 (top-left at cx+2, cy-4)\r\n    for (let y = cy - 4; y < cy - 1; y++) {\r\n        for (let x = cx + 2; x < cx + 5; x++) {\r\n            map[y][x] = TILES.SHOP;\r\n        }\r\n    }\r\n\r\n    // Place \"Mysterious Old House\" (8x4) far south\r\n    // Center X, near bottom Y\r\n    const ohX = cx - 4; // Centered (8 wide means -4 offset)\r\n    const ohY = MAP_HEIGHT - 8; // Near bottom\r\n\r\n    // Clear area for house\r\n    for (let y = ohY - 1; y < ohY + 5; y++) {\r\n        for (let x = ohX - 1; x < ohX + 9; x++) {\r\n            if (y >= 0 && y < MAP_HEIGHT && x >= 0 && x < MAP_WIDTH) {\r\n                map[y][x] = TILES.GRASS;\r\n                // clear trees/stones via return object eventually, \r\n                // but direct map array manip doesn't clear entity lists unless we handle it.\r\n                // Since this is Generate, we are building the initial map, so checking before placing trees/stones is key.\r\n            }\r\n        }\r\n    }\r\n\r\n    // Draw House Tiles\r\n    for (let y = ohY; y < ohY + 4; y++) {\r\n        for (let x = ohX; x < ohX + 8; x++) {\r\n            map[y][x] = TILES.OLD_HOUSE;\r\n        }\r\n    }\r\n\r\n    // Clear area around spawn (larger radius for bigger buildings)\r\n    const radius = MAP_GEN.CLEAR_RADIUS + 1;\r\n    for (let y = cy - radius; y <= cy + radius; y++) {\r\n        for (let x = cx - radius; x <= cx + radius; x++) {\r\n            if (y >= 0 && y < MAP_HEIGHT && x >= 0 && x < MAP_WIDTH) {\r\n                if (map[y][x] === TILES.TREE || map[y][x] === TILES.STONE) {\r\n                    map[y][x] = TILES.GRASS;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    return {\r\n        map,\r\n        npcs: []\r\n    };\r\n}\r\n\r\n/**\r\n * Check if a tile is solid (blocks movement)\r\n * @param {number[][]} map - The game map\r\n * @param {number} x - X coordinate\r\n * @param {number} y - Y coordinate\r\n * @param {object} crops - Crops object for checking planted trees\r\n * @param {object} SEEDS - Seeds data for tree check\r\n * @returns {boolean} Whether tile is solid\r\n */\r\nexport function isSolid(map, x, y, crops = {}, SEEDS = {}) {\r\n    if (x < 0 || x >= MAP_WIDTH || y < 0 || y >= MAP_HEIGHT) {\r\n        return true;\r\n    }\r\n\r\n    const tile = map[y][x];\r\n\r\n    if (tile === TILES.TREE || tile === TILES.TREE_OAK ||\r\n        tile === TILES.HOUSE || tile === TILES.SHOP ||\r\n        tile === TILES.STONE || tile === TILES.STONE_ORE || tile === TILES.STONE_BOULDER ||\r\n        tile === TILES.OLD_HOUSE) {\r\n        return true;\r\n    }\r\n\r\n    // Check if there's a planted tree or trellis crop at this location\r\n    const key = `${x},${y}`;\r\n    const crop = crops[key];\r\n    if (crop && SEEDS[crop.type]) {\r\n        const seedData = SEEDS[crop.type];\r\n        // Trees and trellis crops are solid\r\n        if (seedData.isTree || seedData.isSolid) {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\n/**\r\n * Get the tile type at coordinates\r\n * @param {number[][]} map \r\n * @param {number} x \r\n * @param {number} y \r\n * @returns {number|null} Tile type or null if out of bounds\r\n */\r\nexport function getTile(map, x, y) {\r\n    if (x < 0 || x >= MAP_WIDTH || y < 0 || y >= MAP_HEIGHT) {\r\n        return null;\r\n    }\r\n    return map[y][x];\r\n}\r\n\r\n/**\r\n * Set the tile type at coordinates\r\n * @param {number[][]} map \r\n * @param {number} x \r\n * @param {number} y \r\n * @param {number} tileType \r\n */\r\nexport function setTile(map, x, y, tileType) {\r\n    if (x >= 0 && x < MAP_WIDTH && y >= 0 && y < MAP_HEIGHT) {\r\n        map[y][x] = tileType;\r\n    }\r\n}\r\n\r\nexport default {\r\n    generateMap,\r\n    isSolid,\r\n    getTile,\r\n    setTile\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\njyti\\Desktop\\Google-Antigravity\\2d-farming-game\\src\\systems\\ParticleSystem.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\njyti\\Desktop\\Google-Antigravity\\2d-farming-game\\src\\systems\\Recipes.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'key' is defined but never used. Allowed unused args must match /^_/u.","line":349,"column":19,"nodeType":"Identifier","messageId":"unusedVar","endLine":349,"endColumn":22,"suggestions":[{"messageId":"removeVar","data":{"varName":"key"},"fix":{"range":[9966,9969],"text":""},"desc":"Remove unused variable 'key'."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Crafting and Cooking Recipes\r\n * Recipe-based item transformation system\r\n */\r\n\r\n// Recipe definitions\r\nexport const RECIPES = {\r\n    // === Basic Cooking ===\r\n    turnip_soup: {\r\n        name: 'Turnip Soup',\r\n        inputs: { turnip: 2 },\r\n        output: 'turnip_soup',\r\n        outputCount: 1,\r\n        category: 'cooking',\r\n        requiredStation: 'stove'\r\n    },\r\n    potato_salad: {\r\n        name: 'Potato Salad',\r\n        inputs: { potato: 2, turnip: 1 },\r\n        output: 'potato_salad',\r\n        outputCount: 1,\r\n        category: 'cooking',\r\n        requiredStation: 'stove'\r\n    },\r\n    veggie_stir_fry: {\r\n        name: 'Veggie Stir Fry',\r\n        inputs: { bokchoy: 2, pepper: 1 },\r\n        output: 'veggie_stir_fry',\r\n        outputCount: 1,\r\n        category: 'cooking',\r\n        requiredStation: 'stove'\r\n    },\r\n\r\n    // === Fruit Dishes ===\r\n    berry_smoothie: {\r\n        name: 'Berry Smoothie',\r\n        inputs: { blueberry: 2, strawb: 1 },\r\n        output: 'berry_smoothie',\r\n        outputCount: 1,\r\n        category: 'cooking',\r\n        requiredStation: 'stove'\r\n    },\r\n    fruit_salad: {\r\n        name: 'Fruit Salad',\r\n        inputs: { apple: 1, orange: 1, cherry: 1 },\r\n        output: 'fruit_salad',\r\n        outputCount: 1,\r\n        category: 'cooking',\r\n        requiredStation: 'stove'\r\n    },\r\n    melon_sorbet: {\r\n        name: 'Melon Sorbet',\r\n        inputs: { melon: 2 },\r\n        output: 'melon_sorbet',\r\n        outputCount: 1,\r\n        category: 'cooking',\r\n        requiredStation: 'stove'\r\n    },\r\n    peach_cobbler: {\r\n        name: 'Peach Cobbler',\r\n        inputs: { peach: 2, wheat: 1 },\r\n        output: 'peach_cobbler',\r\n        outputCount: 1,\r\n        category: 'cooking',\r\n        requiredStation: 'stove'\r\n    },\r\n\r\n    // === Advanced Dishes ===\r\n    pumpkin_pie: {\r\n        name: 'Pumpkin Pie',\r\n        inputs: { pump: 2, wheat: 1 },\r\n        output: 'pumpkin_pie',\r\n        outputCount: 1,\r\n        category: 'cooking',\r\n        requiredStation: 'stove'\r\n    },\r\n    spicy_pepper_dish: {\r\n        name: 'Spicy Pepper Dish',\r\n        inputs: { pepper: 3 },\r\n        output: 'spicy_pepper_dish',\r\n        outputCount: 1,\r\n        category: 'cooking',\r\n        requiredStation: 'stove'\r\n    },\r\n    starfruit_deluxe: {\r\n        name: 'Starfruit Deluxe',\r\n        inputs: { starfruit: 1, melon: 1 },\r\n        output: 'starfruit_deluxe',\r\n        outputCount: 1,\r\n        category: 'cooking',\r\n        requiredStation: 'stove'\r\n    },\r\n    cranberry_sauce: {\r\n        name: 'Cranberry Sauce',\r\n        inputs: { cranberry: 3 },\r\n        output: 'cranberry_sauce',\r\n        outputCount: 1,\r\n        category: 'cooking',\r\n        requiredStation: 'stove'\r\n    },\r\n    grape_juice: {\r\n        name: 'Fresh Grape Juice',\r\n        inputs: { grape: 3 },\r\n        output: 'grape_juice',\r\n        outputCount: 1,\r\n        category: 'cooking',\r\n        requiredStation: 'stove'\r\n    },\r\n\r\n    // === Seasonal Specials ===\r\n    spring_salad: {\r\n        name: 'Spring Salad',\r\n        inputs: { radish: 1, kale: 1, parsnip: 1 },\r\n        output: 'spring_salad',\r\n        outputCount: 1,\r\n        category: 'cooking',\r\n        requiredStation: 'stove'\r\n    },\r\n    summer_feast: {\r\n        name: 'Summer Feast',\r\n        inputs: { tomato: 2, corn: 2 },\r\n        output: 'summer_feast',\r\n        outputCount: 1,\r\n        category: 'cooking',\r\n        requiredStation: 'stove'\r\n    },\r\n    fall_harvest_bowl: {\r\n        name: 'Fall Harvest Bowl',\r\n        inputs: { eggplant: 1, yam: 1, beet: 1 },\r\n        output: 'fall_harvest_bowl',\r\n        outputCount: 1,\r\n        category: 'cooking',\r\n        requiredStation: 'stove'\r\n    },\r\n    winter_root_stew: {\r\n        name: 'Winter Root Stew',\r\n        inputs: { winterroot: 2, snowyam: 1 },\r\n        output: 'winter_root_stew',\r\n        outputCount: 1,\r\n        category: 'cooking',\r\n        requiredStation: 'stove'\r\n    },\r\n\r\n    // === Flower Teas (Special Buffs) ===\r\n    tulip_tea: {\r\n        name: 'Tulip Tea',\r\n        inputs: { tulip: 2 },\r\n        output: 'tulip_tea',\r\n        outputCount: 1,\r\n        category: 'cooking',\r\n        requiredStation: 'stove'\r\n    },\r\n    rose_tea: {\r\n        name: 'Rose Tea',\r\n        inputs: { rose: 2 },\r\n        output: 'rose_tea',\r\n        outputCount: 1,\r\n        category: 'cooking',\r\n        requiredStation: 'stove'\r\n    },\r\n    lavender_tea: {\r\n        name: 'Lavender Tea',\r\n        inputs: { lavender: 2 },\r\n        output: 'lavender_tea',\r\n        outputCount: 1,\r\n        category: 'cooking',\r\n        requiredStation: 'stove'\r\n    }\r\n};\r\n\r\n// Consumable effects (food items that can be eaten)\r\nexport const CONSUMABLES = {\r\n    // === Basic Cooked Foods ===\r\n    turnip_soup: { energy: 30, sell: 45, icon: '' },\r\n    potato_salad: { energy: 50, sell: 80, icon: '' },\r\n    veggie_stir_fry: { energy: 60, sell: 100, icon: '' },\r\n\r\n    // === Fruit Dishes (Speed Buffs) ===\r\n    berry_smoothie: {\r\n        energy: 40, sell: 90, icon: '',\r\n        buff: { type: 'speedBoost', duration: 60, value: 1.3 }\r\n    },\r\n    fruit_salad: {\r\n        energy: 80, sell: 150, icon: '',\r\n        buff: { type: 'maxHpBoost', duration: 180, value: 20 }\r\n    },\r\n    melon_sorbet: { energy: 120, sell: 280, icon: '' },\r\n    peach_cobbler: {\r\n        energy: 90, sell: 200, icon: '',\r\n        buff: { type: 'energySaver', duration: 120, value: 0.5 }\r\n    },\r\n\r\n    // === Advanced Dishes ===\r\n    pumpkin_pie: {\r\n        energy: 100, sell: 350, icon: '',\r\n        buff: { type: 'energySaver', duration: 180, value: 0.5 }\r\n    },\r\n    spicy_pepper_dish: {\r\n        energy: 50, sell: 60, icon: '',\r\n        buff: { type: 'speedBoost', duration: 90, value: 1.5 }\r\n    },\r\n    starfruit_deluxe: {\r\n        energy: 150, sell: 500, icon: '',\r\n        buff: { type: 'maxHpBoost', duration: 300, value: 50 }\r\n    },\r\n    cranberry_sauce: { energy: 70, sell: 120, icon: '' },\r\n    grape_juice: {\r\n        energy: 45, sell: 100, icon: '',\r\n        buff: { type: 'speedBoost', duration: 45, value: 1.2 }\r\n    },\r\n\r\n    // === Seasonal Specials ===\r\n    spring_salad: {\r\n        energy: 55, sell: 90, icon: '',\r\n        buff: { type: 'harvestBoost', duration: 120, value: 1.5 }\r\n    },\r\n    summer_feast: {\r\n        energy: 85, sell: 140, icon: '',\r\n        buff: { type: 'speedBoost', duration: 60, value: 1.4 }\r\n    },\r\n    fall_harvest_bowl: {\r\n        energy: 95, sell: 180, icon: '',\r\n        buff: { type: 'maxHpBoost', duration: 240, value: 30 }\r\n    },\r\n    winter_root_stew: {\r\n        energy: 110, sell: 160, icon: '',\r\n        buff: { type: 'energySaver', duration: 150, value: 0.4 }\r\n    },\r\n\r\n    // === Flower Teas ===\r\n    tulip_tea: {\r\n        energy: 25, sell: 40, icon: '',\r\n        buff: { type: 'speedBoost', duration: 30, value: 1.2 }\r\n    },\r\n    rose_tea: {\r\n        energy: 30, sell: 80, icon: '',\r\n        buff: { type: 'maxHpBoost', duration: 120, value: 15 }\r\n    },\r\n    lavender_tea: {\r\n        energy: 35, sell: 100, icon: '',\r\n        buff: { type: 'energySaver', duration: 90, value: 0.6 }\r\n    }\r\n};\r\n\r\n// Active buffs that foods can grant\r\nexport const BUFF_TYPES = {\r\n    energySaver: {\r\n        name: 'Energy Saver',\r\n        description: 'Energy costs reduced',\r\n        icon: '',\r\n        color: '#ffeb3b'\r\n    },\r\n    speedBoost: {\r\n        name: 'Speed Boost',\r\n        description: 'Movement speed increased',\r\n        icon: '',\r\n        color: '#4fc3f7'\r\n    },\r\n    maxHpBoost: {\r\n        name: 'Fortified',\r\n        description: 'Max HP temporarily increased',\r\n        icon: '',\r\n        color: '#ef5350'\r\n    },\r\n    harvestBoost: {\r\n        name: 'Green Thumb',\r\n        description: 'Better harvest yields',\r\n        icon: '',\r\n        color: '#66bb6a'\r\n    }\r\n};\r\n\r\n/**\r\n * Check if player can craft a recipe\r\n * @param {object} inventory - Player inventory\r\n * @param {string} recipeKey - Recipe key from RECIPES\r\n * @returns {boolean}\r\n */\r\nexport function canCraft(inventory, recipeKey) {\r\n    const recipe = RECIPES[recipeKey];\r\n    if (!recipe) return false;\r\n\r\n    for (const [item, count] of Object.entries(recipe.inputs)) {\r\n        const slot = inventory.slots.find(s => s?.name === item);\r\n        if (!slot || slot.count < count) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n\r\n/**\r\n * Craft a recipe\r\n * @param {object} inventory - Player inventory\r\n * @param {string} recipeKey - Recipe key from RECIPES\r\n * @returns {boolean} Whether crafting succeeded\r\n */\r\nexport function craft(inventory, recipeKey) {\r\n    const recipe = RECIPES[recipeKey];\r\n    if (!recipe || !canCraft(inventory, recipeKey)) {\r\n        return false;\r\n    }\r\n\r\n    // Remove inputs\r\n    for (const [item, count] of Object.entries(recipe.inputs)) {\r\n        const slotIdx = inventory.slots.findIndex(s => s?.name === item);\r\n        if (slotIdx !== -1) {\r\n            inventory.removeFromSlot(slotIdx, count);\r\n        }\r\n    }\r\n\r\n    // Add output\r\n    inventory.addItem(recipe.output, recipe.outputCount);\r\n    return true;\r\n}\r\n\r\n/**\r\n * Consume a food item\r\n * @param {object} inventory - Player inventory\r\n * @param {object} timeSystem - Time system for energy\r\n * @param {number} slotIndex - Inventory slot\r\n * @returns {object|null} Buff if granted, or null\r\n */\r\nexport function consumeFood(inventory, timeSystem, slotIndex) {\r\n    const item = inventory.slots[slotIndex];\r\n    if (!item) return null;\r\n\r\n    const consumable = CONSUMABLES[item.name];\r\n    if (!consumable) return null;\r\n\r\n    // Restore energy\r\n    timeSystem.energy = Math.min(\r\n        timeSystem.energy + consumable.energy,\r\n        timeSystem.maxEnergy\r\n    );\r\n\r\n    // Remove one item\r\n    inventory.removeFromSlot(slotIndex, 1);\r\n\r\n    // Return buff if any\r\n    return consumable.buff || null;\r\n}\r\n\r\n/**\r\n * Get available recipes for a station type\r\n */\r\nexport function getRecipesForStation(stationType) {\r\n    return Object.entries(RECIPES)\r\n        .filter(([key, recipe]) => recipe.requiredStation === stationType)\r\n        .map(([key, recipe]) => ({ key, ...recipe }));\r\n}\r\n\r\nexport default {\r\n    RECIPES,\r\n    CONSUMABLES,\r\n    BUFF_TYPES,\r\n    canCraft,\r\n    craft,\r\n    consumeFood,\r\n    getRecipesForStation\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\njyti\\Desktop\\Google-Antigravity\\2d-farming-game\\src\\systems\\SaveManager.js","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":35,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":35,"endColumn":22,"suggestions":[{"fix":{"range":[743,788],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":79,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":79,"endColumn":22,"suggestions":[{"fix":{"range":[1971,2016],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Save Manager\r\n * Handles game save/load with localStorage\r\n */\r\n\r\nimport { SAVE_KEY, AUTO_SAVE_INTERVAL } from '../game/constants.js';\r\nimport { getState, replaceState, createInitialState } from '../game/state.js';\r\n\r\nlet autoSaveInterval = null;\r\nlet onSaveCallback = null;\r\n\r\n/**\r\n * Check if a save exists\r\n * @returns {boolean}\r\n */\r\nexport function hasSave() {\r\n    return localStorage.getItem(SAVE_KEY) !== null;\r\n}\r\n\r\n/**\r\n * Save the current game state\r\n */\r\nexport function saveGame() {\r\n    const state = getState();\r\n\r\n    try {\r\n        localStorage.setItem(SAVE_KEY, JSON.stringify(state));\r\n\r\n        if (onSaveCallback) {\r\n            onSaveCallback();\r\n        }\r\n\r\n        return true;\r\n    } catch (error) {\r\n        console.error('Failed to save game:', error);\r\n        return false;\r\n    }\r\n}\r\n\r\n/**\r\n * Load game from save\r\n * @returns {boolean} Whether load was successful\r\n */\r\nexport function loadGame() {\r\n    try {\r\n        const data = localStorage.getItem(SAVE_KEY);\r\n\r\n        if (!data) {\r\n            return false;\r\n        }\r\n\r\n        const loaded = JSON.parse(data);\r\n        const currentState = getState();\r\n\r\n        // Merge with current state to handle missing properties\r\n        const mergedState = { ...currentState, ...loaded };\r\n\r\n        // Ensure required properties exist\r\n        if (!mergedState.player.facing) {\r\n            mergedState.player.facing = { x: 0, y: 1 };\r\n        }\r\n        if (mergedState.zoom === undefined) {\r\n            mergedState.zoom = 1.0;\r\n        }\r\n        if (mergedState.season === undefined) {\r\n            mergedState.season = 0;\r\n        }\r\n        if (mergedState.energy === undefined) {\r\n            mergedState.energy = 300;\r\n            mergedState.maxEnergy = 300;\r\n        }\r\n        if (mergedState.dayLength === undefined) {\r\n            mergedState.dayLength = 24000;\r\n        }\r\n\r\n        replaceState(mergedState);\r\n        return true;\r\n    } catch (error) {\r\n        console.error('Failed to load game:', error);\r\n        return false;\r\n    }\r\n}\r\n\r\n/**\r\n * Delete save data\r\n */\r\nexport function deleteSave() {\r\n    localStorage.removeItem(SAVE_KEY);\r\n}\r\n\r\n/**\r\n * Reset game and delete save\r\n */\r\nexport function resetGame() {\r\n    deleteSave();\r\n    replaceState(createInitialState());\r\n}\r\n\r\n/**\r\n * Start auto-save interval\r\n */\r\nexport function startAutoSave() {\r\n    if (autoSaveInterval) {\r\n        clearInterval(autoSaveInterval);\r\n    }\r\n\r\n    autoSaveInterval = setInterval(() => {\r\n        const state = getState();\r\n        if (state.screen === 'GAME') {\r\n            saveGame();\r\n        }\r\n    }, AUTO_SAVE_INTERVAL);\r\n}\r\n\r\n/**\r\n * Stop auto-save interval\r\n */\r\nexport function stopAutoSave() {\r\n    if (autoSaveInterval) {\r\n        clearInterval(autoSaveInterval);\r\n        autoSaveInterval = null;\r\n    }\r\n}\r\n\r\n/**\r\n * Set callback for save events (for UI indicator)\r\n * @param {Function} callback \r\n */\r\nexport function onSave(callback) {\r\n    onSaveCallback = callback;\r\n}\r\n\r\nexport default {\r\n    hasSave,\r\n    saveGame,\r\n    loadGame,\r\n    deleteSave,\r\n    resetGame,\r\n    startAutoSave,\r\n    stopAutoSave,\r\n    onSave\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\njyti\\Desktop\\Google-Antigravity\\2d-farming-game\\src\\systems\\TimeSystem.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\njyti\\Desktop\\Google-Antigravity\\2d-farming-game\\src\\ui\\CookingModal.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'key' is defined but never used. Allowed unused args must match /^_/u.","line":59,"column":23,"nodeType":"Identifier","messageId":"unusedVar","endLine":59,"endColumn":26,"suggestions":[{"messageId":"removeVar","data":{"varName":"key"},"fix":{"range":[1631,1634],"text":""},"desc":"Remove unused variable 'key'."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Cooking Modal\r\n * UI for cooking at the stove\r\n */\r\n\r\nimport { RECIPES, CONSUMABLES, BUFF_TYPES, canCraft, craft } from '../systems/Recipes.js';\r\nimport { SEEDS } from '../game/constants.js';\r\n\r\nexport class CookingModal {\r\n    constructor(uiManager, callbacks = {}) {\r\n        this.uiManager = uiManager;\r\n        this.onCook = callbacks.onCook || (() => { });\r\n        this.onConsume = callbacks.onConsume || (() => { });\r\n        this.onClose = callbacks.onClose || (() => { });\r\n\r\n        this.modal = document.getElementById('cooking-modal');\r\n        this.inventory = null;\r\n\r\n        this.setupModal();\r\n    }\r\n\r\n    setupModal() {\r\n        if (!this.modal) return;\r\n\r\n        const closeBtn = this.modal.querySelector('.btn--close');\r\n        if (closeBtn) {\r\n            closeBtn.onclick = () => this.hide();\r\n        }\r\n    }\r\n\r\n    show(inventory) {\r\n        this.inventory = inventory;\r\n        this.render();\r\n        this.modal?.classList.add('modal-overlay--active');\r\n    }\r\n\r\n    hide() {\r\n        this.modal?.classList.remove('modal-overlay--active');\r\n        this.onClose();\r\n    }\r\n\r\n    render() {\r\n        if (!this.modal || !this.inventory) return;\r\n\r\n        const recipeList = this.modal.querySelector('#cooking-recipes');\r\n        const foodList = this.modal.querySelector('#cooked-foods');\r\n\r\n        if (recipeList) {\r\n            recipeList.innerHTML = this.renderRecipes();\r\n        }\r\n\r\n        if (foodList) {\r\n            foodList.innerHTML = this.renderCookedFoods();\r\n        }\r\n    }\r\n\r\n    renderRecipes() {\r\n        const stoveRecipes = Object.entries(RECIPES)\r\n            .filter(([key, recipe]) => recipe.requiredStation === 'stove');\r\n\r\n        if (stoveRecipes.length === 0) {\r\n            return '<div class=\"cooking-empty\">No recipes available</div>';\r\n        }\r\n\r\n        return stoveRecipes.map(([key, recipe]) => {\r\n            const canMake = canCraft(this.inventory, key);\r\n            const ingredients = Object.entries(recipe.inputs)\r\n                .map(([item, count]) => {\r\n                    const seedData = SEEDS[item];\r\n                    const name = seedData ? seedData.name : item;\r\n                    const hasEnough = this.inventory.countItem(item) >= count;\r\n                    return `<span class=\"${hasEnough ? 'has-item' : 'missing-item'}\">${count}x ${name}</span>`;\r\n                })\r\n                .join(' + ');\r\n\r\n            const output = CONSUMABLES[recipe.output];\r\n            const buffInfo = output?.buff ?\r\n                `<div class=\"recipe-buff\">${BUFF_TYPES[output.buff.type]?.icon || ''} ${BUFF_TYPES[output.buff.type]?.name || 'Buff'}</div>` : '';\r\n\r\n            return `\r\n                <div class=\"recipe-card ${canMake ? 'can-craft' : 'cannot-craft'}\" data-recipe=\"${key}\">\r\n                    <div class=\"recipe-icon\">${output?.icon || ''}</div>\r\n                    <div class=\"recipe-name\">${recipe.name}</div>\r\n                    <div class=\"recipe-ingredients\">${ingredients}</div>\r\n                    ${buffInfo}\r\n                    <button class=\"btn btn--cook\" ${canMake ? '' : 'disabled'} data-recipe=\"${key}\">\r\n                        ${canMake ? 'Cook!' : 'Missing Items'}\r\n                    </button>\r\n                </div>\r\n            `;\r\n        }).join('');\r\n    }\r\n\r\n    renderCookedFoods() {\r\n        // Find cooked foods in inventory\r\n        const cookedFoods = this.inventory.slots\r\n            .map((slot, idx) => ({ slot, idx }))\r\n            .filter(({ slot }) => slot && CONSUMABLES[slot.name]);\r\n\r\n        if (cookedFoods.length === 0) {\r\n            return '<div class=\"cooking-empty\">No cooked foods in inventory</div>';\r\n        }\r\n\r\n        return cookedFoods.map(({ slot, idx }) => {\r\n            const consumable = CONSUMABLES[slot.name];\r\n            const buffInfo = consumable?.buff ?\r\n                `<div class=\"food-buff\">${BUFF_TYPES[consumable.buff.type]?.icon || ''} ${BUFF_TYPES[consumable.buff.type]?.name}</div>` : '';\r\n\r\n            return `\r\n                <div class=\"food-chip\" data-slot=\"${idx}\">\r\n                    <span class=\"food-icon\">${consumable?.icon || ''}</span>\r\n                    <span class=\"food-name\">${slot.name.replace(/_/g, ' ')}</span>\r\n                    <span class=\"food-count\">x${slot.count}</span>\r\n                    <span class=\"food-energy\">+${consumable.energy}</span>\r\n                    ${buffInfo}\r\n                    <button class=\"btn btn--eat\" data-slot=\"${idx}\">Eat</button>\r\n                </div>\r\n            `;\r\n        }).join('');\r\n    }\r\n\r\n    bindEvents() {\r\n        if (!this.modal) return;\r\n\r\n        // Cook buttons\r\n        this.modal.querySelectorAll('.btn--cook').forEach(btn => {\r\n            btn.onclick = (e) => {\r\n                const recipeKey = e.target.dataset.recipe;\r\n                if (craft(this.inventory, recipeKey)) {\r\n                    this.onCook(recipeKey);\r\n                    this.render();\r\n                }\r\n            };\r\n        });\r\n\r\n        // Eat buttons\r\n        this.modal.querySelectorAll('.btn--eat').forEach(btn => {\r\n            btn.onclick = (e) => {\r\n                const slotIdx = parseInt(e.target.dataset.slot);\r\n                this.onConsume(slotIdx);\r\n                this.render();\r\n            };\r\n        });\r\n    }\r\n}\r\n\r\nexport default CookingModal;\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\njyti\\Desktop\\Google-Antigravity\\2d-farming-game\\src\\ui\\CreatorModal.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\njyti\\Desktop\\Google-Antigravity\\2d-farming-game\\src\\ui\\DialogueModal.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\njyti\\Desktop\\Google-Antigravity\\2d-farming-game\\src\\ui\\EquipmentModal.js","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":68,"column":17,"nodeType":"MemberExpression","messageId":"unexpected","endLine":68,"endColumn":28,"suggestions":[{"fix":{"range":[2457,2505],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Equipment Modal\r\n * Handles character equipment and stats\r\n */\r\n\r\nimport { Inventory } from '../systems/Inventory.js';\r\n\r\nexport class EquipmentModal {\r\n    constructor(player) {\r\n        this.player = player;\r\n        this.modal = null;\r\n        this.isVisible = false;\r\n    }\r\n\r\n    /**\r\n     * Setup UI elements\r\n     */\r\n    setupUI(modalElement) {\r\n        this.modal = modalElement;\r\n\r\n        // Modal content\r\n        const content = document.createElement('div');\r\n        content.className = 'modal-panel';\r\n        content.innerHTML = `\r\n            <button class=\"btn btn--close\">&times;</button>\r\n            <div class=\"modal-title\">Character</div>\r\n            \r\n            <div class=\"equipment-layout\">\r\n                <div class=\"equipment-row\">\r\n                    <div class=\"equipment-slot\" data-slot=\"head\" data-tooltip=\"Head\"></div>\r\n                </div>\r\n                <div class=\"equipment-row\">\r\n                    <div class=\"equipment-slot equipment-slot--weapon\" data-slot=\"weapon\" data-tooltip=\"Main Hand\"></div>\r\n                    <div class=\"equipment-slot equipment-slot--armor\" data-slot=\"body\" data-tooltip=\"Body\"></div>\r\n                    <div class=\"equipment-slot\" data-slot=\"offhand\" data-tooltip=\"Off Hand\"></div>\r\n                </div>\r\n                <div class=\"equipment-row\">\r\n                    <div class=\"equipment-slot\" data-slot=\"legs\" data-tooltip=\"Legs\"></div>\r\n                </div>\r\n            </div>\r\n\r\n            <div class=\"equipment-stats\">\r\n                <div class=\"stat-row\">\r\n                    <span>Attack</span>\r\n                    <span id=\"stat-attack\">0</span>\r\n                </div>\r\n                <div class=\"stat-row\">\r\n                    <span>Defense</span>\r\n                    <span id=\"stat-defense\">0</span>\r\n                </div>\r\n                <div class=\"stat-row\">\r\n                    <span>Speed</span>\r\n                    <span id=\"stat-speed\">Normal</span>\r\n                </div>\r\n            </div>\r\n        `;\r\n\r\n        this.modal.innerHTML = '';\r\n        this.modal.appendChild(content);\r\n\r\n        // Close button\r\n        content.querySelector('.btn--close').onclick = () => this.hide();\r\n\r\n        // Slot interactions (placeholder for now)\r\n        content.querySelectorAll('.equipment-slot').forEach(slot => {\r\n            slot.onclick = () => {\r\n                // Future: Open selection modal\r\n                console.log('Clicked slot:', slot.dataset.slot);\r\n            };\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Render current equipment\r\n     */\r\n    render() {\r\n        if (!this.player.equipment) return;\r\n\r\n        const slots = this.modal.querySelectorAll('.equipment-slot');\r\n        slots.forEach(slot => {\r\n            const slotType = slot.dataset.slot;\r\n            const item = this.player.equipment[slotType];\r\n\r\n            if (item) {\r\n                slot.innerHTML = Inventory.getIcon(item.key || item.name);\r\n                slot.classList.add('has-item');\r\n            } else {\r\n                // Default placeholders handled by CSS/Initial HTML\r\n                slot.classList.remove('has-item');\r\n                if (slotType === 'head') slot.innerHTML = '';\r\n                if (slotType === 'weapon') slot.innerHTML = '';\r\n                if (slotType === 'body') slot.innerHTML = '';\r\n                if (slotType === 'offhand') slot.innerHTML = '';\r\n                if (slotType === 'legs') slot.innerHTML = '';\r\n            }\r\n        });\r\n\r\n        // Update stats\r\n        const attackEl = this.modal.querySelector('#stat-attack');\r\n        const defenseEl = this.modal.querySelector('#stat-defense');\r\n        if (attackEl) attackEl.innerText = this.player.getAttack();\r\n        if (defenseEl) defenseEl.innerText = '0';\r\n    }\r\n\r\n    /**\r\n     * Show modal\r\n     */\r\n    show() {\r\n        this.isVisible = true;\r\n        this.modal.classList.add('modal-overlay--active');\r\n        this.render();\r\n    }\r\n\r\n    /**\r\n     * Hide modal\r\n     */\r\n    hide() {\r\n        this.isVisible = false;\r\n        this.modal.classList.remove('modal-overlay--active');\r\n    }\r\n\r\n    /**\r\n     * Toggle visibility\r\n     */\r\n    toggle() {\r\n        if (this.isVisible) this.hide();\r\n        else this.show();\r\n    }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\njyti\\Desktop\\Google-Antigravity\\2d-farming-game\\src\\ui\\PetNameModal.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\njyti\\Desktop\\Google-Antigravity\\2d-farming-game\\src\\ui\\ShopModal.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'Inventory' is defined but never used.","line":7,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":7,"endColumn":19,"suggestions":[{"messageId":"removeVar","data":{"varName":"Inventory"},"fix":{"range":[113,165],"text":""},"desc":"Remove unused variable 'Inventory'."}]},{"ruleId":"no-undef","severity":2,"message":"'confirm' is not defined.","line":35,"column":21,"nodeType":"Identifier","messageId":"undef","endLine":35,"endColumn":28}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Shop Modal\r\n * Handles shop buying and selling UI\r\n */\r\n\r\nimport { SEEDS } from '../game/constants.js';\r\nimport { Inventory } from '../systems/Inventory.js';\r\n\r\nexport class ShopModal {\r\n    constructor(uiManager, gameCallbacks) {\r\n        this.uiManager = uiManager;\r\n        this.gameCallbacks = gameCallbacks; // { onBuy, onSell, onClose, onReset }\r\n        this.currentSeason = 0;\r\n\r\n        this.setupEventListeners();\r\n    }\r\n\r\n    /**\r\n     * Setup static event listeners\r\n     */\r\n    setupEventListeners() {\r\n        const closeBtn = document.querySelector('#shop-modal .btn--close');\r\n        if (closeBtn) {\r\n            closeBtn.onclick = () => this.gameCallbacks.onClose();\r\n        }\r\n\r\n        const backBtn = document.querySelector('#shop-modal .btn--back');\r\n        if (backBtn) {\r\n            backBtn.onclick = () => this.gameCallbacks.onClose();\r\n        }\r\n\r\n        const resetBtn = document.querySelector('#shop-modal .btn--reset');\r\n        if (resetBtn) {\r\n            resetBtn.onclick = () => {\r\n                if (confirm('Wipe save data?')) {\r\n                    this.gameCallbacks.onReset();\r\n                }\r\n            };\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Show the shop modal\r\n     */\r\n    show(inventory, currentSeason = 0) {\r\n        this.currentSeason = currentSeason;\r\n        this.uiManager.setShopVisible(true);\r\n        this.render(inventory);\r\n    }\r\n\r\n    /**\r\n     * Hide the shop modal\r\n     */\r\n    hide() {\r\n        this.uiManager.setShopVisible(false);\r\n    }\r\n\r\n    /**\r\n     * Render shop contents\r\n     */\r\n    render(inventory) {\r\n        this.uiManager.renderShop(SEEDS, this.currentSeason, (seedType) => {\r\n            this.gameCallbacks.onBuy(seedType);\r\n            this.render(inventory); // Re-render sell list\r\n        });\r\n\r\n        this.uiManager.renderSellList(inventory, (slotIndex, value) => {\r\n            this.gameCallbacks.onSell(slotIndex, value);\r\n            this.render(inventory); // Re-render after selling\r\n        });\r\n    }\r\n}\r\n\r\nexport default ShopModal;\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\njyti\\Desktop\\Google-Antigravity\\2d-farming-game\\src\\ui\\UIManager.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]}]
